<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Yocto Project Linux Kernel Development Manual</title><link rel="stylesheet" type="text/css" href="css/kernel-dev-style.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.76.1" /></head><body><div xml:lang="en" class="book" title="Yocto Project Linux Kernel Development Manual" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="kernel-dev"></a>
		  Yocto Project Linux Kernel Development Manual
		</h1></div><div><div class="authorgroup">
            <div class="author"><h3 class="author"><span class="firstname">Darren</span> <span class="surname">Hart</span></h3><div class="affiliation">
                    <span class="orgname">Intel Corporation<br /></span>
                </div><code class="email">&lt;<a class="email" href="mailto:darren.hart@intel.com">darren.hart@intel.com</a>&gt;</code></div>
        </div></div><div><p class="copyright">Copyright © 2010-2017 Linux Foundation</p></div><div><div class="legalnotice" title="Legal Notice"><a id="idm46143251905840"></a>
      <p>
        Permission is granted to copy, distribute and/or modify this document under
        the terms of the <a class="ulink" href="http://creativecommons.org/licenses/by-sa/2.0/uk/" target="_top">Creative Commons Attribution-Share Alike 2.0 UK: England &amp; Wales</a> as published by Creative Commons.
      </p>
           <div class="note" title="Manual Notes" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Manual Notes</h3>
               <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                       For the latest version of the Yocto Project Linux
                       Kernel Development Manual associated with this Yocto
                       Project release (version 2.3),
                       see the Yocto Project Linux Kernel Development
                       Manual from the
                       <a class="ulink" href="http://www.yoctoproject.org/documentation" target="_top">Yocto Project documentation page</a>.
                       </p></li><li class="listitem"><p>
                       This version of the manual is version
                       2.3.
                       For later releases of the Yocto Project (if they exist),
                       go to the
                       <a class="ulink" href="http://www.yoctoproject.org/documentation" target="_top">Yocto Project documentation page</a>
                       and use the drop-down "Active Releases" button
                       and choose the Yocto Project version for which you want
                       the manual.
                       </p></li><li class="listitem"><p>
                        For an in-development version of the Yocto Project
                        Linux Kernel Development Manual, see
                        <a class="ulink" href="http://www.yoctoproject.org/docs/latest/kernel-dev/kernel-dev.html" target="_top">http://www.yoctoproject.org/docs/latest/kernel-dev/kernel-dev.html</a>.
                        </p></li></ul></div>
            </div>
    </div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><strong>Revision History</strong></th></tr>
            <tr><td align="left">Revision 1.4</td><td align="left">April 2013</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.4 Release.</td></tr>
            <tr><td align="left">Revision 1.5</td><td align="left">October 2013</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.5 Release.</td></tr>
            <tr><td align="left">Revision 1.5.1</td><td align="left">January 2014</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.5.1 Release.</td></tr>
            <tr><td align="left">Revision 1.6</td><td align="left">April 2014</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.6 Release.</td></tr>
            <tr><td align="left">Revision 1.7</td><td align="left">October 2014</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.7 Release.</td></tr>
            <tr><td align="left">Revision 1.8</td><td align="left">April 2015</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 1.8 Release.</td></tr>
            <tr><td align="left">Revision 2.0</td><td align="left">October 2015</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.0 Release.</td></tr>
            <tr><td align="left">Revision 2.1</td><td align="left">April 2016</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.1 Release.</td></tr>
            <tr><td align="left">Revision 2.2</td><td align="left">October 2016</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.2 Release.</td></tr>
            <tr><td align="left">Revision 2.3</td><td align="left">May 2017</td></tr><tr><td align="left" colspan="2">Released with the Yocto Project 2.3 Release.</td></tr>
        </table></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="chapter"><a href="#kernel-dev-intro">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#kernel-dev-overview">1.1. Overview</a></span></dt><dt><span class="section"><a href="#kernel-dev-other-resources">1.2. Other Resources</a></span></dt></dl></dd><dt><span class="chapter"><a href="#kernel-dev-common">2. Common Tasks</a></span></dt><dd><dl><dt><span class="section"><a href="#creating-and-preparing-a-layer">2.1. Creating and Preparing a Layer</a></span></dt><dt><span class="section"><a href="#modifying-an-existing-recipe">2.2. Modifying an Existing Recipe</a></span></dt><dd><dl><dt><span class="section"><a href="#creating-the-append-file">2.2.1. Creating the Append File</a></span></dt><dt><span class="section"><a href="#applying-patches">2.2.2. Applying Patches</a></span></dt><dt><span class="section"><a href="#changing-the-configuration">2.2.3. Changing the Configuration</a></span></dt><dt><span class="section"><a href="#using-an-in-tree-defconfig-file">2.2.4. Using an "In-Tree"  <code class="filename">defconfig</code> File</a></span></dt></dl></dd><dt><span class="section"><a href="#using-an-iterative-development-process">2.3. Using an Iterative Development Process</a></span></dt><dd><dl><dt><span class="section"><a href="#tip-dirty-string">2.3.1. "-dirty" String</a></span></dt><dt><span class="section"><a href="#generating-configuration-files">2.3.2. Generating Configuration Files</a></span></dt><dt><span class="section"><a href="#modifying-source-code">2.3.3. Modifying Source Code</a></span></dt></dl></dd><dt><span class="section"><a href="#working-with-your-own-sources">2.4. Working With Your Own Sources</a></span></dt><dt><span class="section"><a href="#working-with-out-of-tree-modules">2.5. Working with Out-of-Tree Modules</a></span></dt><dd><dl><dt><span class="section"><a href="#building-out-of-tree-modules-on-the-target">2.5.1. Building Out-of-Tree Modules on the Target</a></span></dt><dt><span class="section"><a href="#incorporating-out-of-tree-modules">2.5.2. Incorporating Out-of-Tree Modules</a></span></dt></dl></dd><dt><span class="section"><a href="#inspecting-changes-and-commits">2.6. Inspecting Changes and Commits</a></span></dt><dd><dl><dt><span class="section"><a href="#what-changed-in-a-kernel">2.6.1. What Changed in a Kernel?</a></span></dt><dt><span class="section"><a href="#showing-a-particular-feature-or-branch-change">2.6.2. Showing a Particular Feature or Branch Change</a></span></dt></dl></dd><dt><span class="section"><a href="#adding-recipe-space-kernel-features">2.7. Adding Recipe-Space Kernel Features</a></span></dt></dl></dd><dt><span class="chapter"><a href="#kernel-dev-advanced">3. Working with Advanced Metadata</a></span></dt><dd><dl><dt><span class="section"><a href="#kernel-dev-advanced-overview">3.1. Overview</a></span></dt><dt><span class="section"><a href="#using-kernel-metadata-in-a-recipe">3.2. Using Kernel Metadata in a Recipe</a></span></dt><dt><span class="section"><a href="#kernel-metadata-syntax">3.3. Kernel Metadata Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration">3.3.1. Configuration</a></span></dt><dt><span class="section"><a href="#patches">3.3.2. Patches</a></span></dt><dt><span class="section"><a href="#features">3.3.3. Features</a></span></dt><dt><span class="section"><a href="#kernel-types">3.3.4. Kernel Types</a></span></dt><dt><span class="section"><a href="#bsp-descriptions">3.3.5. BSP Descriptions</a></span></dt></dl></dd><dt><span class="section"><a href="#kernel-metadata-location">3.4. Kernel Metadata Location</a></span></dt><dd><dl><dt><span class="section"><a href="#recipe-space-metadata">3.4.1. Recipe-Space Metadata</a></span></dt><dt><span class="section"><a href="#metadata-outside-the-recipe-space">3.4.2. Metadata Outside the Recipe-Space</a></span></dt></dl></dd><dt><span class="section"><a href="#organizing-your-source">3.5. Organizing Your Source</a></span></dt><dd><dl><dt><span class="section"><a href="#encapsulating-patches">3.5.1. Encapsulating Patches</a></span></dt><dt><span class="section"><a href="#machine-branches">3.5.2. Machine Branches</a></span></dt><dt><span class="section"><a href="#feature-branches">3.5.3. Feature Branches</a></span></dt></dl></dd><dt><span class="section"><a href="#scc-reference">3.6. SCC Description File Reference</a></span></dt></dl></dd><dt><span class="appendix"><a href="#kernel-dev-concepts-appx">A. Advanced Kernel Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#kernel-big-picture">A.1. Yocto Project Kernel Development and Maintenance</a></span></dt><dt><span class="section"><a href="#kernel-architecture">A.2. Kernel Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture-overview">A.2.1. Overview</a></span></dt><dt><span class="section"><a href="#branching-and-workflow">A.2.2. Branching Strategy and Workflow</a></span></dt><dt><span class="section"><a href="#source-code-manager-git">A.2.3. Source Code Manager - Git</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#kernel-dev-maint-appx">B. Kernel Maintenance</a></span></dt><dd><dl><dt><span class="section"><a href="#tree-construction">B.1. Tree Construction</a></span></dt><dt><span class="section"><a href="#build-strategy">B.2. Build Strategy</a></span></dt></dl></dd><dt><span class="appendix"><a href="#kernel-dev-faq">C. Kernel Development FAQ</a></span></dt><dd><dl><dt><span class="section"><a href="#kernel-dev-faq-section">C.1. Common Questions and Solutions</a></span></dt></dl></dd></dl></div>
    

    <div class="chapter" title="Chapter 1. Introduction"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-dev-intro"></a>Chapter 1. Introduction<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-intro">¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#kernel-dev-overview">1.1. Overview</a></span></dt><dt><span class="section"><a href="#kernel-dev-other-resources">1.2. Other Resources</a></span></dt></dl></div><div class="section" title="1.1. Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-dev-overview"></a>1.1. Overview<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-overview">¶</a></span></h2></div></div></div><p>
            Regardless of how you intend to make use of the Yocto Project,
            chances are you will work with the Linux kernel.
            This manual provides background information on the Yocto Linux kernel
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#metadata" target="_top">Metadata</a>,
            describes common tasks you can perform using the kernel tools,
            and shows you how to use the kernel Metadata needed to work with
            the kernel inside the Yocto Project.
       </p><p>
            Each Yocto Project release has a set of linux-yocto recipes, whose
            Git repositories you can view in the Yocto
            <a class="ulink" href="http://git.yoctoproject.org" target="_top">Source Repositories</a> under
            the "Yocto Linux Kernel" heading.
            New recipes for the release track the latest upstream developments
            and introduce newly-supported platforms.
            Previous recipes in the release are refreshed and supported for at
            least one additional release.
            As they align, these previous releases are updated to include the
            latest from the
            <a class="ulink" href="http://www.yoctoproject.org/organization/long-term-support-initiative-ltsi" target="_top">Long Term Support Initiative</a>
            (LTSI) project.
            Also included is a linux-yocto development recipe
            (<code class="filename">linux-yocto-dev.bb</code>) should you want to work
            with the very latest in upstream Linux kernel development and
            kernel Metadata development.
        </p><p>
            The Yocto Project also provides a powerful set of kernel
            tools for managing Linux kernel sources and configuration data.
            You can use these tools to make a single configuration change,
            apply multiple patches, or work with your own kernel sources.
        </p><p>
            In particular, the kernel tools allow you to generate configuration
            fragments that specify only what you must, and nothing more.
            Configuration fragments only need to contain the highest level
            visible <code class="filename">CONFIG</code> options as presented by the Linux
            kernel <code class="filename">menuconfig</code> system.
            Contrast this against a complete Linux kernel
            <code class="filename">.config</code>, which includes all the automatically
            selected <code class="filename">CONFIG</code> options.
            This efficiency reduces your maintenance effort and allows you
            to further separate your configuration in ways that make sense for
            your project.
            A common split separates policy and hardware.
            For example, all your kernels might support
            the <code class="filename">proc</code> and <code class="filename">sys</code> filesystems,
            but only specific boards require sound, USB, or specific drivers.
            Specifying these configurations individually allows you to aggregate
            them together as needed, but maintains them in only one place.
            Similar logic applies to separating source changes.
        </p><p>
            If you do not maintain your own kernel sources and need to make
            only minimal changes to the sources, the released recipes provide a
            vetted base upon which to layer your changes.
            Doing so allows you to benefit from the continual kernel
            integration and testing performed during development of the
            Yocto Project.
        </p><p>
            If, instead, you have a very specific Linux kernel source tree
            and are unable to align with one of the official linux-yocto
            recipes, an alternative exists by which you can use the Yocto
            Project Linux kernel tools with your own kernel sources.
        </p></div><div class="section" title="1.2. Other Resources"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-dev-other-resources"></a>1.2. Other Resources<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-other-resources">¶</a></span></h2></div></div></div><p>
            The sections that follow provide instructions for completing
            specific Linux kernel development tasks.
            These instructions assume you are comfortable working with
            <a class="ulink" href="http://openembedded.org/wiki/Bitbake" target="_top">BitBake</a>
            recipes and basic open-source development tools.
            Understanding these concepts will facilitate the process of working
            with the kernel recipes.
            If you find you need some additional background, please be sure to
            review and understand the following documentation:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/yocto-project-qs/yocto-project-qs.html" target="_top">Yocto Project Quick Start</a>
                    </p></li><li class="listitem"><p>The "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#dev-modifying-source-code" target="_top">Modifying Source Code</a>"
                    section in the Yocto Project Development Manual
                    </p></li><li class="listitem"><p>The "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#understanding-and-creating-layers" target="_top">Understanding and Creating Layers</a>" section
                    in the Yocto Project Development Manual</p></li><li class="listitem"><p>The "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#modifying-the-kernel" target="_top">Modifying the Kernel</a>" section
                    in the Yocto Project Development Manual.</p></li></ul></div><p>
        </p><p>
            Finally, while this document focuses on the manual creation of
            recipes, patches, and configuration files, the Yocto Project
            Board Support Package (BSP) tools are available to automate
            this process with existing content and work well to create the
            initial framework and boilerplate code.
            For details on these tools, see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/bsp-guide/bsp-guide.html#using-the-yocto-projects-bsp-tools" target="_top">Using the Yocto Project's BSP Tools</a>"
            section in the Yocto Project Board Support Package (BSP) Developer's
            Guide.
        </p></div></div>

    <div class="chapter" title="Chapter 2. Common Tasks"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-dev-common"></a>Chapter 2. Common Tasks<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-common">¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#creating-and-preparing-a-layer">2.1. Creating and Preparing a Layer</a></span></dt><dt><span class="section"><a href="#modifying-an-existing-recipe">2.2. Modifying an Existing Recipe</a></span></dt><dd><dl><dt><span class="section"><a href="#creating-the-append-file">2.2.1. Creating the Append File</a></span></dt><dt><span class="section"><a href="#applying-patches">2.2.2. Applying Patches</a></span></dt><dt><span class="section"><a href="#changing-the-configuration">2.2.3. Changing the Configuration</a></span></dt><dt><span class="section"><a href="#using-an-in-tree-defconfig-file">2.2.4. Using an "In-Tree"  <code class="filename">defconfig</code> File</a></span></dt></dl></dd><dt><span class="section"><a href="#using-an-iterative-development-process">2.3. Using an Iterative Development Process</a></span></dt><dd><dl><dt><span class="section"><a href="#tip-dirty-string">2.3.1. "-dirty" String</a></span></dt><dt><span class="section"><a href="#generating-configuration-files">2.3.2. Generating Configuration Files</a></span></dt><dt><span class="section"><a href="#modifying-source-code">2.3.3. Modifying Source Code</a></span></dt></dl></dd><dt><span class="section"><a href="#working-with-your-own-sources">2.4. Working With Your Own Sources</a></span></dt><dt><span class="section"><a href="#working-with-out-of-tree-modules">2.5. Working with Out-of-Tree Modules</a></span></dt><dd><dl><dt><span class="section"><a href="#building-out-of-tree-modules-on-the-target">2.5.1. Building Out-of-Tree Modules on the Target</a></span></dt><dt><span class="section"><a href="#incorporating-out-of-tree-modules">2.5.2. Incorporating Out-of-Tree Modules</a></span></dt></dl></dd><dt><span class="section"><a href="#inspecting-changes-and-commits">2.6. Inspecting Changes and Commits</a></span></dt><dd><dl><dt><span class="section"><a href="#what-changed-in-a-kernel">2.6.1. What Changed in a Kernel?</a></span></dt><dt><span class="section"><a href="#showing-a-particular-feature-or-branch-change">2.6.2. Showing a Particular Feature or Branch Change</a></span></dt></dl></dd><dt><span class="section"><a href="#adding-recipe-space-kernel-features">2.7. Adding Recipe-Space Kernel Features</a></span></dt></dl></div><p>
    This chapter presents several common tasks you perform when you
    work with the Yocto Project Linux kernel.
    These tasks include preparing a layer, modifying an existing recipe,
    iterative development, working with your own sources, and incorporating
    out-of-tree modules.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        The examples presented in this chapter work with the Yocto Project
        1.2.2 Release and forward.
    </div><p>
</p><div class="section" title="2.1. Creating and Preparing a Layer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="creating-and-preparing-a-layer"></a>2.1. Creating and Preparing a Layer<span class="permalink"><a alt="Permalink" title="Permalink" href="#creating-and-preparing-a-layer">¶</a></span></h2></div></div></div><p>
            If you are going to be modifying kernel recipes, it is recommended
            that you create and prepare your own layer in which to do your
            work.
            Your layer contains its own
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#bitbake-term" target="_top">BitBake</a>
            append files
            (<code class="filename">.bbappend</code>) and provides a convenient
            mechanism to create your own recipe files
            (<code class="filename">.bb</code>).
            For details on how to create and work with layers, see the following
            sections in the Yocto Project Development Manual:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>"<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#understanding-and-creating-layers" target="_top">Understanding and Creating Layers</a>" for
                    general information on layers and how to create layers.</p></li><li class="listitem"><p>"<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#set-up-your-layer-for-the-build" target="_top">Set Up Your Layer for the Build</a>" for
                    specific instructions on setting up a layer for kernel
                    development.</p></li></ul></div><p>
        </p></div><div class="section" title="2.2. Modifying an Existing Recipe"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="modifying-an-existing-recipe"></a>2.2. Modifying an Existing Recipe<span class="permalink"><a alt="Permalink" title="Permalink" href="#modifying-an-existing-recipe">¶</a></span></h2></div></div></div><p>
            In many cases, you can customize an existing linux-yocto recipe to
            meet the needs of your project.
            Each release of the Yocto Project provides a few Linux
            kernel recipes from which you can choose.
            These are located in the
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#source-directory" target="_top">Source Directory</a>
            in <code class="filename">meta/recipes-kernel/linux</code>.
        </p><p>
            Modifying an existing recipe can consist of the following:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Creating the append file</p></li><li class="listitem"><p>Applying patches</p></li><li class="listitem"><p>Changing the configuration</p></li></ul></div><p>
        </p><p>
            Before modifying an existing recipe, be sure that you have created
            a minimal, custom layer from which you can work.
            See the "<a class="link" href="#creating-and-preparing-a-layer" title="2.1. Creating and Preparing a Layer">Creating and Preparing a Layer</a>"
            section for some general resources.
            You can also see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#set-up-your-layer-for-the-build" target="_top">Set Up Your Layer for the Build</a>" section
            of the Yocto Project Development Manual for a detailed
            example.
        </p><div class="section" title="2.2.1. Creating the Append File"><div class="titlepage"><div><div><h3 class="title"><a id="creating-the-append-file"></a>2.2.1. Creating the Append File<span class="permalink"><a alt="Permalink" title="Permalink" href="#creating-the-append-file">¶</a></span></h3></div></div></div><p>
                You create this file in your custom layer.
                You also name it accordingly based on the linux-yocto recipe
                you are using.
                For example, if you are modifying the
                <code class="filename">meta/recipes-kernel/linux/linux-yocto_4.4.bb</code>
                recipe, the append file will typically be located as follows
                within your custom layer:
                </p><pre class="literallayout">
     <em class="replaceable"><code>your-layer</code></em>/recipes-kernel/linux/linux-yocto_4.4.bbappend
                </pre><p>
                The append file should initially extend the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESPATH" target="_top"><code class="filename">FILESPATH</code></a>
                search path by prepending the directory that contains your
                files to the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESEXTRAPATHS" target="_top"><code class="filename">FILESEXTRAPATHS</code></a>
                variable as follows:
                </p><pre class="literallayout">
     FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
                </pre><p>
                The path <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-THISDIR" target="_top"><code class="filename">THISDIR</code></a><code class="filename">}/${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PN" target="_top"><code class="filename">PN</code></a><code class="filename">}</code>
                expands to "linux-yocto" in the current directory for this
                example.
                If you add any new files that modify the kernel recipe and you
                have extended <code class="filename">FILESPATH</code> as
                described above, you must place the files in your layer in the
                following area:
                </p><pre class="literallayout">
     <em class="replaceable"><code>your-layer</code></em>/recipes-kernel/linux/linux-yocto/
                </pre><p>
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>If you are working on a new machine Board Support Package
                    (BSP), be sure to refer to the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/bsp-guide/bsp-guide.html" target="_top">Yocto Project Board Support Package (BSP) Developer's Guide</a>.
                </div><p>
            </p><p>
                As an example, consider the following append file
                used by the BSPs in <code class="filename">meta-yocto-bsp</code>:
                </p><pre class="literallayout">
     meta-yocto-bsp/recipes-kernel/linux/linux-yocto_4.4.bbappend
                </pre><p>
                The following listing shows the file.
                Be aware that the actual commit ID strings in this
                example listing might be different than the actual strings
                in the file from the <code class="filename">meta-yocto-bsp</code>
                layer upstream.
                </p><pre class="literallayout">
     KBRANCH_genericx86  = "standard/base"
     KBRANCH_genericx86-64  = "standard/base"

     KMACHINE_genericx86 ?= "common-pc"
     KMACHINE_genericx86-64 ?= "common-pc-64"
     KBRANCH_edgerouter = "standard/edgerouter"
     KBRANCH_beaglebone = "standard/beaglebone"
     KBRANCH_mpc8315e-rdb = "standard/fsl-mpc8315e-rdb"

     SRCREV_machine_genericx86    ?= "ad8b1d659ddd2699ebf7d50ef9de8940b157bfc2"
     SRCREV_machine_genericx86-64 ?= "ad8b1d659ddd2699ebf7d50ef9de8940b157bfc2"
     SRCREV_machine_edgerouter ?= "cebe1ad56aebd89e0de29412e19433fb441bf13c"
     SRCREV_machine_beaglebone ?= "cebe1ad56aebd89e0de29412e19433fb441bf13c"
     SRCREV_machine_mpc8315e-rdb ?= "06c0dbdcba374ca7f92a53d69292d6bb7bc9b0f3"

     COMPATIBLE_MACHINE_genericx86 = "genericx86"
     COMPATIBLE_MACHINE_genericx86-64 = "genericx86-64"
     COMPATIBLE_MACHINE_edgerouter = "edgerouter"
     COMPATIBLE_MACHINE_beaglebone = "beaglebone"
     COMPATIBLE_MACHINE_mpc8315e-rdb = "mpc8315e-rdb"

     LINUX_VERSION_genericx86 = "4.4.41"
     LINUX_VERSION_genericx86-64 = "4.4.41"
     LINUX_VERSION_edgerouter = "4.4.53"
     LINUX_VERSION_beaglebone = "4.4.53"
     LINUX_VERSION_mpc8315e-rdb = "4.4.53"
                </pre><p>
                This append file contains statements used to support
                several BSPs that ship with the Yocto Project.
                The file defines machines using the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-COMPATIBLE_MACHINE" target="_top"><code class="filename">COMPATIBLE_MACHINE</code></a>
                variable and uses the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KMACHINE" target="_top"><code class="filename">KMACHINE</code></a>
                variable to ensure the machine name used by the OpenEmbedded
                build system maps to the machine name used by the Linux Yocto
                kernel.
                The file also uses the optional
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KBRANCH" target="_top"><code class="filename">KBRANCH</code></a>
                variable to ensure the build process uses the
                appropriate kernel branch.
            </p><p>
                Although this particular example does not use it, the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KERNEL_FEATURES" target="_top"><code class="filename">KERNEL_FEATURES</code></a>
                variable could be used to enable features specific to
                the kernel.
                The append file points to specific commits in the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#source-directory" target="_top">Source Directory</a>
                Git repository and the <code class="filename">meta</code> Git repository
                branches to identify the exact kernel needed to build the
                BSP.
            </p><p>
                One thing missing in this particular BSP, which you will
                typically need when developing a BSP, is the kernel configuration
                file (<code class="filename">.config</code>) for your BSP.
                When developing a BSP, you probably have a kernel configuration
                file or a set of kernel configuration files that, when taken
                together, define the kernel configuration for your BSP.
                You can accomplish this definition by putting the configurations
                in a file or a set of files inside a directory located at the
                same level as your kernel's append file and having the same
                name as the kernel's main recipe file.
                With all these conditions met, simply reference those files in the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                statement in the append file.
            </p><p>
                For example, suppose you had some configuration options
                in a file called <code class="filename">network_configs.cfg</code>.
                You can place that file inside a directory named
                <code class="filename">linux-yocto</code> and then add
                a <code class="filename">SRC_URI</code> statement such as the
                following to the append file.
                When the OpenEmbedded build system builds the kernel, the
                configuration options are picked up and applied.
                </p><pre class="literallayout">
     SRC_URI += "file://network_configs.cfg"
                </pre><p>
            </p><p>
                To group related configurations into multiple files, you
                perform a similar procedure.
                Here is an example that groups separate configurations
                specifically for Ethernet and graphics into their own
                files and adds the configurations by using a
                <code class="filename">SRC_URI</code> statement like the following
                in your append file:
                </p><pre class="literallayout">
     SRC_URI += "file://myconfig.cfg \
                 file://eth.cfg \
                 file://gfx.cfg"
                </pre><p>
            </p><p>
                Another variable you can use in your kernel recipe append
                file is the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESEXTRAPATHS" target="_top"><code class="filename">FILESEXTRAPATHS</code></a>
                variable.
                When you use this statement, you are extending the locations
                used by the OpenEmbedded system to look for files and
                patches as the recipe is processed.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                    Other methods exist to accomplish grouping and defining configuration options.
                    For example, if you are working with a local clone of the kernel repository,
                    you could checkout the kernel's <code class="filename">meta</code> branch, make your changes,
                    and then push the changes to the local bare clone of the kernel.
                    The result is that you directly add configuration options to the
                    <code class="filename">meta</code> branch for your BSP.
                    The configuration options will likely end up in that location anyway if the BSP gets
                    added to the Yocto Project.
                </p><p>
                    In general, however, the Yocto Project maintainers take care of moving the
                    <code class="filename">SRC_URI</code>-specified
                    configuration options to the kernel's <code class="filename">meta</code> branch.
                    Not only is it easier for BSP developers to not have to worry about putting those
                    configurations in the branch, but having the maintainers do it allows them to apply
                    'global' knowledge about the kinds of common configuration options multiple BSPs in
                    the tree are typically using.
                    This allows for promotion of common configurations into common features.
                </p></div></div><div class="section" title="2.2.2. Applying Patches"><div class="titlepage"><div><div><h3 class="title"><a id="applying-patches"></a>2.2.2. Applying Patches<span class="permalink"><a alt="Permalink" title="Permalink" href="#applying-patches">¶</a></span></h3></div></div></div><p>
                If you have a single patch or a small series of patches
                that you want to apply to the Linux kernel source, you
                can do so just as you would with any other recipe.
                You first copy the patches to the path added to
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESEXTRAPATHS" target="_top"><code class="filename">FILESEXTRAPATHS</code></a>
                in your <code class="filename">.bbappend</code> file as described in
                the previous section, and then reference them in
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                statements.
            </p><p>
                For example, you can apply a three-patch series by adding the
                following lines to your linux-yocto
                <code class="filename">.bbappend</code> file in your layer:
                </p><pre class="literallayout">
     SRC_URI += "file://0001-first-change.patch"
     SRC_URI += "file://0002-second-change.patch"
     SRC_URI += "file://0003-third-change.patch"
                </pre><p>
                The next time you run BitBake to build the Linux kernel,
                BitBake detects the change in the recipe and fetches and
                applies the patches before building the kernel.
            </p><p>
                For a detailed example showing how to patch the kernel, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#patching-the-kernel" target="_top">Patching the Kernel</a>"
                section in the Yocto Project Development Manual.
            </p></div><div class="section" title="2.2.3. Changing the Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="changing-the-configuration"></a>2.2.3. Changing the Configuration<span class="permalink"><a alt="Permalink" title="Permalink" href="#changing-the-configuration">¶</a></span></h3></div></div></div><p>
                You can make wholesale or incremental changes to the final
                <code class="filename">.config</code> file used for the eventual
                Linux kernel configuration by including a
                <code class="filename">defconfig</code> file and by specifying
                configuration fragments in the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                to be applied to that file.
            </p><p>
                If you have a complete, working Linux kernel
                <code class="filename">.config</code>
                file you want to use for the configuration, as before, copy
                that file to the appropriate <code class="filename">${PN}</code>
                directory in your layer's
                <code class="filename">recipes-kernel/linux</code> directory,
                and rename the copied file to "defconfig".
                Then, add the following lines to the linux-yocto
                <code class="filename">.bbappend</code> file in your layer:
                </p><pre class="literallayout">
     FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
     SRC_URI += "file://defconfig"
                </pre><p>
                The <code class="filename">SRC_URI</code> tells the build system how to
                search for the file, while the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESEXTRAPATHS" target="_top"><code class="filename">FILESEXTRAPATHS</code></a>
                extends the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESPATH" target="_top"><code class="filename">FILESPATH</code></a>
                variable (search directories) to include the
                <code class="filename">${PN}</code> directory you created to hold the
                configuration changes.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                The build system applies the configurations from the
                <code class="filename">defconfig</code> file before applying any
                subsequent configuration fragments.
                The final kernel configuration is a combination of the
                configurations in the <code class="filename">defconfig</code> file and
                any configuration fragments you provide.
                You need to realize that if you have any configuration
                fragments, the build system applies these on top of and
                after applying the existing <code class="filename">defconfig</code>
                file configurations.
            </div><p>
                Generally speaking, the preferred approach is to determine the
                incremental change you want to make and add that as a
                configuration fragment.
                For example, if you want to add support for a basic serial
                console, create a file named <code class="filename">8250.cfg</code> in
                the <code class="filename">${PN}</code> directory with the following
                content (without indentation):
                </p><pre class="literallayout">
     CONFIG_SERIAL_8250=y
     CONFIG_SERIAL_8250_CONSOLE=y
     CONFIG_SERIAL_8250_PCI=y
     CONFIG_SERIAL_8250_NR_UARTS=4
     CONFIG_SERIAL_8250_RUNTIME_UARTS=4
     CONFIG_SERIAL_CORE=y
     CONFIG_SERIAL_CORE_CONSOLE=y
                </pre><p>
                Next, include this configuration fragment and extend the
                <code class="filename">FILESPATH</code> variable in your
                <code class="filename">.bbappend</code> file:
                </p><pre class="literallayout">
     FILESEXTRAPATHS_prepend := "${THISDIR}/${PN}:"
     SRC_URI += "file://8250.cfg"
                </pre><p>
                The next time you run BitBake to build the Linux kernel, BitBake
                detects the change in the recipe and fetches and applies the
                new configuration before building the kernel.
            </p><p>
                For a detailed example showing how to configure the kernel,
                see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#configuring-the-kernel" target="_top">Configuring the Kernel</a>"
                section in the Yocto Project Development Manual.
            </p></div><div class="section" title="2.2.4. Using an &quot;In-Tree&quot;  defconfig File"><div class="titlepage"><div><div><h3 class="title"><a id="using-an-in-tree-defconfig-file"></a>2.2.4. Using an "In-Tree"  <code class="filename">defconfig</code> File<span class="permalink"><a alt="Permalink" title="Permalink" href="#using-an-in-tree-defconfig-file">¶</a></span></h3></div></div></div><p>
                It might be desirable to have kernel configuration fragment
                support through a <code class="filename">defconfig</code> file that
                is pulled from the kernel source tree for the configured
                machine.
                By default, the OpenEmbedded build system looks for
                <code class="filename">defconfig</code> files in the layer used for
                Metadata, which is "out-of-tree", and then configures them
                using the following:
                </p><pre class="literallayout">
     SRC_URI += "file://defconfig"
                </pre><p>
                If you do not want to maintain copies of
                <code class="filename">defconfig</code> files in your layer but would
                rather allow users to use the default configuration from the
                kernel tree and still be able to add configuration fragments
                to the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                through, for example, append files, you can direct the
                OpenEmbedded build system to use a
                <code class="filename">defconfig</code> file that is "in-tree".
            </p><p>
                To specify an "in-tree" <code class="filename">defconfig</code> file,
                edit the recipe that builds your kernel so that it has the
                following command form:
                </p><pre class="literallayout">
     KBUILD_DEFCONFIG_KMACHINE ?= <em class="replaceable"><code>defconfig_file</code></em>
                </pre><p>
                You need to append the variable with
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KMACHINE" target="_top"><code class="filename">KMACHINE</code></a>
                and then supply the path to your "in-tree"
                <code class="filename">defconfig</code> file.
            </p><p>
                Aside from modifying your kernel recipe and providing your own
                <code class="filename">defconfig</code> file, you need to be sure no
                files or statements set <code class="filename">SRC_URI</code> to use a
                <code class="filename">defconfig</code> other than your "in-tree"
                file (e.g. a kernel's <code class="filename">linux-</code><em class="replaceable"><code>machine</code></em><code class="filename">.inc</code>
                file).
                In other words, if the build system detects a statement
                that identifies an "out-of-tree"
                <code class="filename">defconfig</code> file, that statement
                will override your
                <code class="filename">KBUILD_DEFCONFIG</code> variable.
            </p><p>
                See the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KBUILD_DEFCONFIG" target="_top"><code class="filename">KBUILD_DEFCONFIG</code></a>
                variable description for more information.
            </p></div></div><div class="section" title="2.3. Using an Iterative Development Process"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="using-an-iterative-development-process"></a>2.3. Using an Iterative Development Process<span class="permalink"><a alt="Permalink" title="Permalink" href="#using-an-iterative-development-process">¶</a></span></h2></div></div></div><p>
            If you do not have existing patches or configuration files,
            you can iteratively generate them from within the BitBake build
            environment as described within this section.
            During an iterative workflow, running a previously completed BitBake
            task causes BitBake to invalidate the tasks that follow the
            completed task in the build sequence.
            Invalidated tasks rebuild the next time you run the build using
            BitBake.
        </p><p>
            As you read this section, be sure to substitute the name
            of your Linux kernel recipe for the term
            "linux-yocto".
        </p><div class="section" title="2.3.1. &quot;-dirty&quot; String"><div class="titlepage"><div><div><h3 class="title"><a id="tip-dirty-string"></a>2.3.1. "-dirty" String<span class="permalink"><a alt="Permalink" title="Permalink" href="#tip-dirty-string">¶</a></span></h3></div></div></div><p>
                If kernel images are being built with "-dirty" on the
                end of the version string, this simply means that
                modifications in the source directory have not been committed.
                </p><pre class="literallayout">
     $ git status
                </pre><p>
            </p><p>
                You can use the above Git command to report modified,
                removed, or added files.
                You should commit those changes to the tree regardless of
                whether they will be saved, exported, or used.
                Once you commit the changes, you need to rebuild the kernel.
            </p><p>
                To force a pickup and commit of all such pending changes,
                enter the following:
                </p><pre class="literallayout">
     $ git add .
     $ git commit -s -a -m "getting rid of -dirty"
                </pre><p>
            </p><p>
                Next, rebuild the kernel.
            </p></div><div class="section" title="2.3.2. Generating Configuration Files"><div class="titlepage"><div><div><h3 class="title"><a id="generating-configuration-files"></a>2.3.2. Generating Configuration Files<span class="permalink"><a alt="Permalink" title="Permalink" href="#generating-configuration-files">¶</a></span></h3></div></div></div><p>
                You can manipulate the <code class="filename">.config</code> file
                used to build a linux-yocto recipe with the
                <code class="filename">menuconfig</code> command as follows:
                </p><pre class="literallayout">
     $ bitbake linux-yocto -c menuconfig
                </pre><p>
                This command starts the Linux kernel configuration tool,
                which allows you to prepare a new
                <code class="filename">.config</code> file for the build.
                When you exit the tool, be sure to save your changes
                at the prompt.
            </p><p>
                The resulting <code class="filename">.config</code> file is
                located in the build directory,
                <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-B" target="_top"><code class="filename">B</code></a><code class="filename">}</code>,
                which expands to
                <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-WORKDIR" target="_top"><code class="filename">WORKDIR</code></a><code class="filename">}</code><code class="filename">/linux-</code><code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PACKAGE_ARCH" target="_top"><code class="filename">PACKAGE_ARCH</code></a><code class="filename">}-${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LINUX_KERNEL_TYPE" target="_top"><code class="filename">LINUX_KERNEL_TYPE</code></a><code class="filename">}-build</code>.
                You can use the entire <code class="filename">.config</code> file as the
                <code class="filename">defconfig</code> file as described in the
                "<a class="link" href="#changing-the-configuration" title="2.2.3. Changing the Configuration">Changing the Configuration</a>" section.
                For more information on the <code class="filename">.config</code> file,
                see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#using-menuconfig" target="_top">Using <code class="filename">menuconfig</code></a>"
                section in the Yocto Project Development Manual.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    You can determine what a variable expands to by looking
                    at the output of the <code class="filename">bitbake -e</code>
                    command:
                    <pre class="literallayout">
     $ bitbake -e virtual/kernel
                    </pre>
                    Search the output for the variable in which you are
                    interested to see exactly how it is expanded and used.
                </div><p>
            </p><p>
                A better method is to create a configuration fragment using the
                differences between two configuration files: one previously
                created and saved, and one freshly created using the
                <code class="filename">menuconfig</code> tool.
            </p><p>
                To create a configuration fragment using this method, follow
                these steps:
                </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Complete a build at least through the kernel
                        configuration task as follows:
                        </p><pre class="literallayout">
     $ bitbake linux-yocto -c kernel_configme -f
                        </pre><p>
                        This step ensures that you will be creating a
                        <code class="filename">.config</code> file from a known state.
                        Because situations exist where your build state might
                        become unknown, it is best to run the previous
                        command prior to starting up
                        <code class="filename">menuconfig</code>.
                        </p></li><li class="listitem"><p>Run the <code class="filename">menuconfig</code>
                        command:
                        </p><pre class="literallayout">
     $ bitbake linux-yocto -c menuconfig
                        </pre></li><li class="listitem"><p>Run the <code class="filename">diffconfig</code>
                        command to prepare a configuration fragment.
                        The resulting file <code class="filename">fragment.cfg</code>
                        will be placed in the
                        <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-WORKDIR" target="_top"><code class="filename">WORKDIR</code></a><code class="filename">}</code> directory:
                        </p><pre class="literallayout">
     $ bitbake linux-yocto -c diffconfig
                        </pre></li></ol></div><p>
            </p><p>
                The <code class="filename">diffconfig</code> command creates a file that is a
                list of Linux kernel <code class="filename">CONFIG_</code> assignments.
                See the "<a class="link" href="#changing-the-configuration" title="2.2.3. Changing the Configuration">Changing the Configuration</a>"
                section for information on how to use the output as a
                configuration fragment.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    You can also use this method to create configuration
                    fragments for a BSP.
                    See the "<a class="link" href="#bsp-descriptions" title="3.3.5. BSP Descriptions">BSP Descriptions</a>"
                    section for more information.
                </div><p>
            </p><p>
                The kernel tools also provide configuration validation.
                You can use these tools to produce warnings for when a
                requested configuration does not appear in the final
                <code class="filename">.config</code> file or when you override a
                policy configuration in a hardware configuration fragment.
                Here is an example with some sample output of the command
                that runs these tools:
                </p><pre class="literallayout">
     $ bitbake linux-yocto -c kernel_configcheck -f

     ...

     NOTE: validating kernel configuration
     This BSP sets 3 invalid/obsolete kernel options.
     These config options are not offered anywhere within this kernel.
     The full list can be found in your kernel src dir at:
     meta/cfg/standard/mybsp/invalid.cfg

     This BSP sets 21 kernel options that are possibly non-hardware related.
     The full list can be found in your kernel src dir at:
     meta/cfg/standard/mybsp/specified_non_hdw.cfg

     WARNING: There were 2 hardware options requested that do not
              have a corresponding value present in the final ".config" file.
              This probably means you are not getting the config you wanted.
              The full list can be found in your kernel src dir at:
              meta/cfg/standard/mybsp/mismatch.cfg
                </pre><p>
            </p><p>
                The output describes the various problems that you can
                encounter along with where to find the offending configuration
                items.
                You can use the information in the logs to adjust your
                configuration files and then repeat the
                <code class="filename">kernel_configme</code> and
                <code class="filename">kernel_configcheck</code> commands until
                they produce no warnings.
            </p><p>
                For more information on how to use the
                <code class="filename">menuconfig</code> tool, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#using-menuconfig" target="_top">Using <code class="filename">menuconfig</code></a>"
                section in the Yocto Project Development Manual.
            </p></div><div class="section" title="2.3.3. Modifying Source Code"><div class="titlepage"><div><div><h3 class="title"><a id="modifying-source-code"></a>2.3.3. Modifying Source Code<span class="permalink"><a alt="Permalink" title="Permalink" href="#modifying-source-code">¶</a></span></h3></div></div></div><p>
                You can experiment with source code changes and create a
                simple patch without leaving the BitBake environment.
                To get started, be sure to complete a build at
                least through the kernel configuration task:
                </p><pre class="literallayout">
     $ bitbake linux-yocto -c kernel_configme -f
                </pre><p>
                Taking this step ensures you have the sources prepared
                and the configuration completed.
                You can find the sources in the build directory within the
                <code class="filename">source/</code> directory, which is a symlink
                (i.e. <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-B" target="_top"><code class="filename">B</code></a><code class="filename">}/source</code>).
                The <code class="filename">source/</code> directory expands to
                <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-WORKDIR" target="_top"><code class="filename">WORKDIR</code></a><code class="filename">}</code><code class="filename">/linux-</code><code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PACKAGE_ARCH" target="_top"><code class="filename">PACKAGE_ARCH</code></a><code class="filename">}-${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LINUX_KERNEL_TYPE" target="_top"><code class="filename">LINUX_KERNEL_TYPE</code></a><code class="filename">}-build/source</code>.
                The directory pointed to by the
                <code class="filename">source/</code> symlink is also known as
                <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-STAGING_KERNEL_DIR" target="_top"><code class="filename">STAGING_KERNEL_DIR</code></a><code class="filename">}</code>.
            </p><p>
                You can edit the sources as you would any other Linux source
                tree.
                However, keep in mind that you will lose changes if you
                trigger the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#ref-tasks-fetch" target="_top"><code class="filename">do_fetch</code></a>
                task for the recipe.
                You can avoid triggering this task by not using BitBake to
                run the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#ref-tasks-cleanall" target="_top"><code class="filename">cleanall</code></a>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#ref-tasks-cleansstate" target="_top"><code class="filename">cleansstate</code></a>,
                or forced
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#ref-tasks-fetch" target="_top"><code class="filename">fetch</code></a>
                commands.
                Also, do not modify the recipe itself while working
                with temporary changes or BitBake might run the
                <code class="filename">fetch</code> command depending on the
                changes to the recipe.
            </p><p>
                To test your temporary changes, instruct BitBake to run the
                <code class="filename">compile</code> again.
                The <code class="filename">-f</code> option forces the command to run
                even though BitBake might think it has already done so:
                </p><pre class="literallayout">
     $ bitbake linux-yocto -c compile -f
                </pre><p>
                If the compile fails, you can update the sources and repeat
                the <code class="filename">compile</code>.
                Once compilation is successful, you can inspect and test
                the resulting build (i.e. kernel, modules, and so forth) from
                the following build directory:
                </p><pre class="literallayout">
     ${WORKDIR}/linux-${PACKAGE_ARCH}-${LINUX_KERNEL_TYPE}-build
                </pre><p>
                Alternatively, you can run the <code class="filename">deploy</code>
                command to place the kernel image in the
                <code class="filename">tmp/deploy/images</code> directory:
                </p><pre class="literallayout">
	$ bitbake linux-yocto -c deploy
                </pre><p>
                And, of course, you can perform the remaining installation and
                packaging steps by issuing:
                </p><pre class="literallayout">
	$ bitbake linux-yocto
                </pre><p>
            </p><p>
                For rapid iterative development, the edit-compile-repeat loop
                described in this section is preferable to rebuilding the
                entire recipe because the installation and packaging tasks
                are very time consuming.
            </p><p>
                Once you are satisfied with your source code modifications,
                you can make them permanent by generating patches and
                applying them to the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                statement as described in the
                "<a class="link" href="#applying-patches" title="2.2.2. Applying Patches">Applying Patches</a>"
                section.
                If you are not familiar with generating patches, refer to the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#creating-the-patch" target="_top">Creating the Patch</a>"
                section in the Yocto Project Development Manual.
            </p></div></div><div class="section" title="2.4. Working With Your Own Sources"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="working-with-your-own-sources"></a>2.4. Working With Your Own Sources<span class="permalink"><a alt="Permalink" title="Permalink" href="#working-with-your-own-sources">¶</a></span></h2></div></div></div><p>
            If you cannot work with one of the Linux kernel
            versions supported by existing linux-yocto recipes, you can
            still make use of the Yocto Project Linux kernel tooling by
            working with your own sources.
            When you use your own sources, you will not be able to
            leverage the existing kernel
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#metadata" target="_top">Metadata</a> and
            stabilization work of the linux-yocto sources.
            However, you will be able to manage your own Metadata in the same
            format as the linux-yocto sources.
            Maintaining format compatibility facilitates converging with
            linux-yocto on a future, mutually-supported kernel version.
        </p><p>
            To help you use your own sources, the Yocto Project provides a
            linux-yocto custom recipe
            (<code class="filename">linux-yocto-custom.bb</code>) that uses
            <code class="filename">kernel.org</code> sources
            and the Yocto Project Linux kernel tools for managing
            kernel Metadata.
            You can find this recipe in the
            <code class="filename">poky</code> Git repository of the
            Yocto Project <a class="ulink" href="http://git.yoctoproject.org" target="_top">Source Repository</a>
            at:
            </p><pre class="literallayout">
     poky/meta-skeleton/recipes-kernel/linux/linux-yocto-custom.bb
            </pre><p>
        </p><p>
            Here are some basic steps you can use to work with your own sources:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Copy the <code class="filename">linux-yocto-custom.bb</code>
                    recipe to your layer and give it a meaningful name.
                    The name should include the version of the Linux kernel you
                    are using (e.g.
                    <code class="filename">linux-yocto-myproject_3.19.bb</code>,
                    where "3.19" is the base version of the Linux kernel
                    with which you would be working).</p></li><li class="listitem"><p>In the same directory inside your layer,
                    create a matching directory
                    to store your patches and configuration files (e.g.
                    <code class="filename">linux-yocto-myproject</code>).
                    </p></li><li class="listitem"><p>Make sure you have either a
                    <code class="filename">defconfig</code> file or configuration
                    fragment files.
                    When you use the <code class="filename">linux-yocto-custom.bb</code>
                    recipe, you must specify a configuration.
                    If you do not have a <code class="filename">defconfig</code> file,
                    you can run the following:
                    </p><pre class="literallayout">
     $ make defconfig
                    </pre><p>
                    After running the command, copy the resulting
                    <code class="filename">.config</code> to the
                    <code class="filename">files</code> directory as "defconfig" and
                    then add it to the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                    variable in the recipe.</p><p>Running the <code class="filename">make defconfig</code>
                    command results in the default configuration for your
                    architecture as defined by your kernel.
                    However, no guarantee exists that this configuration is
                    valid for your use case, or that your board will even boot.
                    This is particularly true for non-x86 architectures.
                    To use non-x86 <code class="filename">defconfig</code> files, you
                    need to be more specific and find one that matches your
                    board (i.e. for arm, you look in
                    <code class="filename">arch/arm/configs</code> and use the one that
                    is the best starting point for your board).
                    </p></li><li class="listitem"><p>Edit the following variables in your recipe
                    as appropriate for your project:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>:
                            The <code class="filename">SRC_URI</code> should specify
                            a Git repository that uses one of the supported Git
                            fetcher protocols (i.e. <code class="filename">file</code>,
                            <code class="filename">git</code>, <code class="filename">http</code>,
                            and so forth).
                            The <code class="filename">SRC_URI</code> variable should
                            also specify either a <code class="filename">defconfig</code>
                            file or some configuration fragment files.
                            The skeleton recipe provides an example
                            <code class="filename">SRC_URI</code> as a syntax reference.
                            </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LINUX_VERSION" target="_top"><code class="filename">LINUX_VERSION</code></a>:
                            The Linux kernel version you are using (e.g.
                            "3.19").</p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LINUX_VERSION_EXTENSION" target="_top"><code class="filename">LINUX_VERSION_EXTENSION</code></a>:
                            The Linux kernel <code class="filename">CONFIG_LOCALVERSION</code>
                            that is compiled into the resulting kernel and visible
                            through the <code class="filename">uname</code> command.
                            </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRCREV" target="_top"><code class="filename">SRCREV</code></a>:
                            The commit ID from which you want to build.
                            </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PR" target="_top"><code class="filename">PR</code></a>:
                            Treat this variable the same as you would in any other
                            recipe.
                            Increment the variable to indicate to the OpenEmbedded
                            build system that the recipe has changed.
                            </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PV" target="_top"><code class="filename">PV</code></a>:
                            The default <code class="filename">PV</code> assignment is
                            typically adequate.
                            It combines the <code class="filename">LINUX_VERSION</code>
                            with the Source Control Manager (SCM) revision
                            as derived from the
                            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRCPV" target="_top"><code class="filename">SRCPV</code></a>
                            variable.
                            The combined results are a string with
                            the following form:
                            </p><pre class="literallayout">
     3.19.11+git1+68a635bf8dfb64b02263c1ac80c948647cc76d5f_1+218bd8d2022b9852c60d32f0d770931e3cf343e2
                            </pre><p>
                            While lengthy, the extra verbosity in <code class="filename">PV</code>
                            helps ensure you are using the exact
                            sources from which you intend to build.
                            </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-COMPATIBLE_MACHINE" target="_top"><code class="filename">COMPATIBLE_MACHINE</code></a>:
                            A list of the machines supported by your new recipe.
                            This variable in the example recipe is set
                            by default to a regular expression that matches
                            only the empty string, "(^$)".
                            This default setting triggers an explicit build
                            failure.
                            You must change it to match a list of the machines
                            that your new recipe supports.
                            For example, to support the <code class="filename">qemux86</code>
                            and <code class="filename">qemux86-64</code> machines, use
                            the following form:
                            </p><pre class="literallayout">
     COMPATIBLE_MACHINE = "qemux86|qemux86-64"
                            </pre></li></ul></div></li><li class="listitem"><p>Provide further customizations to your recipe
                    as needed just as you would customize an existing
                    linux-yocto recipe.
                    See the "<a class="link" href="#modifying-an-existing-recipe" title="2.2. Modifying an Existing Recipe">Modifying
                    an Existing Recipe</a>" section for information.
                    </p></li></ol></div><p>
        </p></div><div class="section" title="2.5. Working with Out-of-Tree Modules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="working-with-out-of-tree-modules"></a>2.5. Working with Out-of-Tree Modules<span class="permalink"><a alt="Permalink" title="Permalink" href="#working-with-out-of-tree-modules">¶</a></span></h2></div></div></div><p>
            This section describes steps to build out-of-tree modules on
            your target and describes how to incorporate out-of-tree modules
            in the build.
        </p><div class="section" title="2.5.1. Building Out-of-Tree Modules on the Target"><div class="titlepage"><div><div><h3 class="title"><a id="building-out-of-tree-modules-on-the-target"></a>2.5.1. Building Out-of-Tree Modules on the Target<span class="permalink"><a alt="Permalink" title="Permalink" href="#building-out-of-tree-modules-on-the-target">¶</a></span></h3></div></div></div><p>
                While the traditional Yocto Project development model would be
                to include kernel modules as part of the normal build
                process, you might find it useful to build modules on the
                target.
                This could be the case if your target system is capable
                and powerful enough to handle the necessary compilation.
                Before deciding to build on your target, however, you should
                consider the benefits of using a proper cross-development
                environment from your build host.
            </p><p>
                If you want to be able to build out-of-tree modules on
                the target, there are some steps you need to take
                on the target that is running your SDK image.
                Briefly, the <code class="filename">kernel-dev</code> package
                is installed by default on all
                <code class="filename">*.sdk</code> images and the
                <code class="filename">kernel-devsrc</code> package is installed
                on many of the <code class="filename">*.sdk</code> images.
                However, you need to create some scripts prior to
                attempting to build the out-of-tree modules on the target
                that is running that image.
            </p><p>
                Prior to attempting to build the out-of-tree modules,
                you need to be on the target as root and you need to
                change to the <code class="filename">/usr/src/kernel</code> directory.
                Next, <code class="filename">make</code> the scripts:
                </p><pre class="literallayout">
     # cd /usr/src/kernel
     # make scripts
                </pre><p>
                Because all SDK image recipes include
                <code class="filename">dev-pkgs</code>, the
                <code class="filename">kernel-dev</code> packages will be installed
                as part of the SDK image and the
                <code class="filename">kernel-devsrc</code> packages will be installed
                as part of applicable SDK images.
                The SDK uses the scripts when building out-of-tree
                modules.
                Once you have switched to that directory and created the
                scripts, you should be able to build your out-of-tree modules
                on the target.
            </p></div><div class="section" title="2.5.2. Incorporating Out-of-Tree Modules"><div class="titlepage"><div><div><h3 class="title"><a id="incorporating-out-of-tree-modules"></a>2.5.2. Incorporating Out-of-Tree Modules<span class="permalink"><a alt="Permalink" title="Permalink" href="#incorporating-out-of-tree-modules">¶</a></span></h3></div></div></div><p>
                While it is always preferable to work with sources integrated
                into the Linux kernel sources, if you need an external kernel
                module, the <code class="filename">hello-mod.bb</code> recipe is
                available as a template from which you can create your
                own out-of-tree Linux kernel module recipe.
            </p><p>
                This template recipe is located in the
                <code class="filename">poky</code> Git repository of the
                Yocto Project <a class="ulink" href="http://git.yoctoproject.org" target="_top">Source Repository</a>
                at:
                </p><pre class="literallayout">
     poky/meta-skeleton/recipes-kernel/hello-mod/hello-mod_0.1.bb
                </pre><p>
            </p><p>
                To get started, copy this recipe to your layer and give it a
                meaningful name (e.g. <code class="filename">mymodule_1.0.bb</code>).
                In the same directory, create a new directory named
                <code class="filename">files</code> where you can store any source files,
                patches, or other files necessary for building
                the module that do not come with the sources.
                Finally, update the recipe as needed for the module.
                Typically, you will need to set the following variables:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-DESCRIPTION" target="_top"><code class="filename">DESCRIPTION</code></a>
                        </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LICENSE" target="_top"><code class="filename">LICENSE*</code></a>
                        </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
                        </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PV" target="_top"><code class="filename">PV</code></a>
                        </p></li></ul></div><p>
            </p><p>
                Depending on the build system used by the module sources,
                you might need to make some adjustments.
                For example, a typical module <code class="filename">Makefile</code>
                looks much like the one provided with the
                <code class="filename">hello-mod</code> template:
                </p><pre class="literallayout">
     obj-m := hello.o

     SRC := $(shell pwd)

     all:
         $(MAKE) -C $(KERNEL_SRC) M=$(SRC)

     modules_install:
         $(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install
     ...
                </pre><p>
            </p><p>
                The important point to note here is the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KERNEL_SRC" target="_top"><code class="filename">KERNEL_SRC</code></a>
                variable.
                The
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#ref-classes-module" target="_top"><code class="filename">module</code></a>
                class sets this variable and the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KERNEL_PATH" target="_top"><code class="filename">KERNEL_PATH</code></a>
                variable to
                <code class="filename">${<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-STAGING_KERNEL_DIR" target="_top"><code class="filename">STAGING_KERNEL_DIR</code></a>}</code>
                with the necessary Linux kernel build information to build
                modules.
                If your module <code class="filename">Makefile</code> uses a different
                variable, you might want to override the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#ref-tasks-compile" target="_top"><code class="filename">do_compile()</code></a>
                step, or create a patch to
                the <code class="filename">Makefile</code> to work with the more typical
                <code class="filename">KERNEL_SRC</code> or
                <code class="filename">KERNEL_PATH</code> variables.
            </p><p>
                After you have prepared your recipe, you will likely want to
                include the module in your images.
                To do this, see the documentation for the following variables in
                the Yocto Project Reference Manual and set one of them
                appropriately for your machine configuration file:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_ESSENTIAL_EXTRA_RDEPENDS" target="_top"><code class="filename">MACHINE_ESSENTIAL_EXTRA_RDEPENDS</code></a>
                        </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS" target="_top"><code class="filename">MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS</code></a>
                        </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_EXTRA_RDEPENDS" target="_top"><code class="filename">MACHINE_EXTRA_RDEPENDS</code></a>
                        </p></li><li class="listitem"><p><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_EXTRA_RRECOMMENDS" target="_top"><code class="filename">MACHINE_EXTRA_RRECOMMENDS</code></a>
                        </p></li></ul></div><p>
            </p><p>
                Modules are often not required for boot and can be excluded from
                certain build configurations.
                The following allows for the most flexibility:
                </p><pre class="literallayout">
     MACHINE_EXTRA_RRECOMMENDS += "kernel-module-mymodule"
                </pre><p>
                The value is derived by appending the module filename without
                the <code class="filename">.ko</code> extension to the string
                "kernel-module-".
            </p><p>
                Because the variable is
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-RRECOMMENDS" target="_top"><code class="filename">RRECOMMENDS</code></a>
                and not a
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-RDEPENDS" target="_top"><code class="filename">RDEPENDS</code></a>
                variable, the build will not fail if this module is not
                available to include in the image.
            </p></div></div><div class="section" title="2.6. Inspecting Changes and Commits"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="inspecting-changes-and-commits"></a>2.6. Inspecting Changes and Commits<span class="permalink"><a alt="Permalink" title="Permalink" href="#inspecting-changes-and-commits">¶</a></span></h2></div></div></div><p>
            A common question when working with a kernel is:
            "What changes have been applied to this tree?"
            Rather than using "grep" across directories to see what has
            changed, you can use Git to inspect or search the kernel tree.
            Using Git is an efficient way to see what has changed in the tree.
        </p><div class="section" title="2.6.1. What Changed in a Kernel?"><div class="titlepage"><div><div><h3 class="title"><a id="what-changed-in-a-kernel"></a>2.6.1. What Changed in a Kernel?<span class="permalink"><a alt="Permalink" title="Permalink" href="#what-changed-in-a-kernel">¶</a></span></h3></div></div></div><p>
                Following are a few examples that show how to use Git
                commands to examine changes.
                These examples are by no means the only way to see changes.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    In the following examples, unless you provide a commit
                    range, <code class="filename">kernel.org</code> history is blended
                    with Yocto Project kernel changes.
                    You can form ranges by using branch names from the
                    kernel tree as the upper and lower commit markers with
                    the Git commands.
                    You can see the branch names through the web interface
                    to the Yocto Project source repositories at
                    <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>.
                </div><p>
                To see a full range of the changes, use the
                <code class="filename">git whatchanged</code> command and specify a
                commit range for the branch
                (<em class="replaceable"><code>commit</code></em><code class="filename">..</code><em class="replaceable"><code>commit</code></em>).
            </p><p>
                Here is an example that looks at what has changed in the
                <code class="filename">emenlow</code> branch of the
                <code class="filename">linux-yocto-3.19</code> kernel.
                The lower commit range is the commit associated with the
                <code class="filename">standard/base</code> branch, while
                the upper commit range is the commit associated with the
                <code class="filename">standard/emenlow</code> branch.
                </p><pre class="literallayout">
     $ git whatchanged origin/standard/base..origin/standard/emenlow
                </pre><p>
            </p><p>
                To see short, one line summaries of changes use the
                <code class="filename">git log</code> command:
                </p><pre class="literallayout">
     $ git log --oneline origin/standard/base..origin/standard/emenlow
                </pre><p>
            </p><p>
                Use this command to see code differences for the changes:
                </p><pre class="literallayout">
     $ git diff origin/standard/base..origin/standard/emenlow
                </pre><p>
            </p><p>
                Use this command to see the commit log messages and the
                text differences:
                </p><pre class="literallayout">
     $ git show origin/standard/base..origin/standard/emenlow
                </pre><p>
            </p><p>
                Use this command to create individual patches for
                each change.
                Here is an example that that creates patch files for each
                commit and places them in your <code class="filename">Documents</code>
                directory:
                </p><pre class="literallayout">
     $ git format-patch -o $HOME/Documents origin/standard/base..origin/standard/emenlow
                </pre><p>
            </p></div><div class="section" title="2.6.2. Showing a Particular Feature or Branch Change"><div class="titlepage"><div><div><h3 class="title"><a id="showing-a-particular-feature-or-branch-change"></a>2.6.2. Showing a Particular Feature or Branch Change<span class="permalink"><a alt="Permalink" title="Permalink" href="#showing-a-particular-feature-or-branch-change">¶</a></span></h3></div></div></div><p>
                Tags in the Yocto Project kernel tree divide changes for
                significant features or branches.
                The <code class="filename">git show</code> <em class="replaceable"><code>tag</code></em>
                command shows changes based on a tag.
                Here is an example that shows <code class="filename">systemtap</code>
                changes:
                </p><pre class="literallayout">
     $ git show systemtap
                </pre><p>
                You can use the
                <code class="filename">git branch --contains</code> <em class="replaceable"><code>tag</code></em>
                command to show the branches that contain a particular feature.
                This command shows the branches that contain the
                <code class="filename">systemtap</code> feature:
                </p><pre class="literallayout">
     $ git branch --contains systemtap
                </pre><p>
            </p></div></div><div class="section" title="2.7. Adding Recipe-Space Kernel Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="adding-recipe-space-kernel-features"></a>2.7. Adding Recipe-Space Kernel Features<span class="permalink"><a alt="Permalink" title="Permalink" href="#adding-recipe-space-kernel-features">¶</a></span></h2></div></div></div><p>
            You can add kernel features in the
            <a class="link" href="#recipe-space-metadata" title="3.4.1. Recipe-Space Metadata">recipe-space</a> by
            using the
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KERNEL_FEATURES" target="_top"><code class="filename">KERNEL_FEATURES</code></a>
            variable and by specifying the feature's <code class="filename">.scc</code>
            file path in the
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
            statement.
            When you add features using this method, the OpenEmbedded build
            system checks to be sure the features are present.
            If the features are not present, the build stops.
            Kernel features are the last elements processed for configuring
            and patching the kernel.
            Therefore, adding features in this manner is a way
            to enforce specific features are present and enabled
            without needing to do a full audit of any other layer's additions
            to the <code class="filename">SRC_URI</code> statement.
        </p><p>
            You add a kernel feature by providing the feature as part of the
            <code class="filename">KERNEL_FEATURES</code> variable and by providing the
            path to the feature's <code class="filename">.scc</code> file, which is
            relative to the root of the kernel Metadata.
            The OpenEmbedded build system searches all forms of kernel
            Metadata on the <code class="filename">SRC_URI</code> statement regardless
            of whether the Metadata is in the "kernel-cache", system kernel
            Metadata, or a recipe-space Metadata.
            See the
            "<a class="link" href="#kernel-metadata-location" title="3.4. Kernel Metadata Location">Kernel Metadata Location</a>"
            section for additional information.
        </p><p>
            When you specify the feature's <code class="filename">.scc</code> file
            on the <code class="filename">SRC_URI</code> statement, the OpenEmbedded
            build system adds the directory of that
            <code class="filename">.scc</code> file along with all its subdirectories
            to the kernel feature search path.
            Because subdirectories are searched, you can reference a single
            <code class="filename">.scc</code> file in the
            <code class="filename">SRC_URI</code> statement to reference multiple kernel
            features.
        </p><p>
            Consider the following example that adds the "test.scc" feature
            to the build.
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    Create a <code class="filename">.scc</code> file and locate it
                    just as you would any other patch file,
                    <code class="filename">.cfg</code> file, or fetcher item
                    you specify in the <code class="filename">SRC_URI</code>
                    statement.
                    </p><div class="note" title="Notes" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Notes</h3><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                                You must add the directory of the
                                <code class="filename">.scc</code> file to the fetcher's
                                search path in the same manner as you would
                                add a <code class="filename">.patch</code> file.
                                </p></li><li class="listitem"><p>
                                You can create additional
                                <code class="filename">.scc</code> files beneath the
                                directory that contains the file you are
                                adding.
                                All subdirectories are searched during the
                                build as potential feature directories.
                                </p></li></ul></div></div><p>
                    Continuing with the example, suppose the "test.scc"
                    feature you are adding has a
                    <code class="filename">test.scc</code> file in the following
                    directory:
                    </p><pre class="literallayout">
     <em class="replaceable"><code>my_recipe</code></em>
        |
        +-linux-yocto
           |
           +-test.cfg
           +-test.scc
                    </pre><p>
                    In this example, the <code class="filename">linux-yocto</code>
                    directory has both the feature
                    <code class="filename">test.scc</code> file and a similarly
                    named configuration fragment file
                    <code class="filename">test.cfg</code>.
                    </p></li><li class="listitem"><p>
                    Add the <code class="filename">.scc</code> file to the
                    recipe's <code class="filename">SRC_URI</code> statement:
                    </p><pre class="literallayout">
     SRC_URI_append = " file://test.scc"
                    </pre><p>
                    The leading space before the path is important as the
                    path is appended to the existing path.
                    </p></li><li class="listitem"><p>
                    Specify the feature as a kernel feature:
                    </p><pre class="literallayout">
     KERNEL_FEATURES_append = " test.scc"
                    </pre><p>
                    The OpenEmbedded build system processes the kernel feature
                    when it builds the kernel.
                    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                        If other features are contained below "test.scc",
                        then their directories are relative to the directory
                        containing the <code class="filename">test.scc</code> file.
                    </div><p>
                    </p></li></ol></div><p>
        </p></div></div>

    <div class="chapter" title="Chapter 3. Working with Advanced Metadata"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-dev-advanced"></a>Chapter 3. Working with Advanced Metadata<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-advanced">¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#kernel-dev-advanced-overview">3.1. Overview</a></span></dt><dt><span class="section"><a href="#using-kernel-metadata-in-a-recipe">3.2. Using Kernel Metadata in a Recipe</a></span></dt><dt><span class="section"><a href="#kernel-metadata-syntax">3.3. Kernel Metadata Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="#configuration">3.3.1. Configuration</a></span></dt><dt><span class="section"><a href="#patches">3.3.2. Patches</a></span></dt><dt><span class="section"><a href="#features">3.3.3. Features</a></span></dt><dt><span class="section"><a href="#kernel-types">3.3.4. Kernel Types</a></span></dt><dt><span class="section"><a href="#bsp-descriptions">3.3.5. BSP Descriptions</a></span></dt></dl></dd><dt><span class="section"><a href="#kernel-metadata-location">3.4. Kernel Metadata Location</a></span></dt><dd><dl><dt><span class="section"><a href="#recipe-space-metadata">3.4.1. Recipe-Space Metadata</a></span></dt><dt><span class="section"><a href="#metadata-outside-the-recipe-space">3.4.2. Metadata Outside the Recipe-Space</a></span></dt></dl></dd><dt><span class="section"><a href="#organizing-your-source">3.5. Organizing Your Source</a></span></dt><dd><dl><dt><span class="section"><a href="#encapsulating-patches">3.5.1. Encapsulating Patches</a></span></dt><dt><span class="section"><a href="#machine-branches">3.5.2. Machine Branches</a></span></dt><dt><span class="section"><a href="#feature-branches">3.5.3. Feature Branches</a></span></dt></dl></dd><dt><span class="section"><a href="#scc-reference">3.6. SCC Description File Reference</a></span></dt></dl></div><div class="section" title="3.1. Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-dev-advanced-overview"></a>3.1. Overview<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-advanced-overview">¶</a></span></h2></div></div></div><p>
        In addition to supporting configuration fragments and patches, the
        Yocto Project kernel tools also support rich
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#metadata" target="_top">Metadata</a> that you can
        use to define complex policies and Board Support Package (BSP) support.
        The purpose of the Metadata and the tools that manage it, known as
        the kern-tools (<code class="filename">kern-tools-native_git.bb</code>), is
        to help you manage the complexity of the configuration and sources
        used to support multiple BSPs and Linux kernel types.
    </p></div><div class="section" title="3.2. Using Kernel Metadata in a Recipe"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="using-kernel-metadata-in-a-recipe"></a>3.2. Using Kernel Metadata in a Recipe<span class="permalink"><a alt="Permalink" title="Permalink" href="#using-kernel-metadata-in-a-recipe">¶</a></span></h2></div></div></div><p>
        The kernel sources in the Yocto Project contain kernel Metadata, which
        is located in the <code class="filename">meta</code> branches of the kernel
        source Git repositories.
        This Metadata defines Board Support Packages (BSPs) that
        correspond to definitions in linux-yocto recipes for the same BSPs.
        A BSP consists of an aggregation of kernel policy and enabled
        hardware-specific features.
        The BSP can be influenced from within the linux-yocto recipe.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            Linux kernel source that contains kernel Metadata is said to be
            "linux-yocto style" kernel source.
            A Linux kernel recipe that inherits from the
            <code class="filename">linux-yocto.inc</code> include file is said to be a
            "linux-yocto style" recipe.
        </div><p>
    </p><p>
        Every linux-yocto style recipe must define the
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KMACHINE" target="_top"><code class="filename">KMACHINE</code></a>
        variable.
        This variable is typically set to the same value as the
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE" target="_top"><code class="filename">MACHINE</code></a>
        variable, which is used by
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#bitbake-term" target="_top">BitBake</a>.
        However, in some cases, the variable might instead refer to the
        underlying platform of the <code class="filename">MACHINE</code>.
    </p><p>
        Multiple BSPs can reuse the same <code class="filename">KMACHINE</code>
        name if they are built using the same BSP description.
        The "ep108-zynqmp" and "qemuzynqmp" BSP combination
        in the <code class="filename">meta-xilinx</code>
        layer is a good example of two BSPs using the same
        <code class="filename">KMACHINE</code> value (i.e. "zynqmp").
        See the <a class="link" href="#bsp-descriptions" title="3.3.5. BSP Descriptions">BSP Descriptions</a> section
        for more information.
    </p><p>
        Every linux-yocto style recipe must also indicate the Linux kernel
        source repository branch used to build the Linux kernel.
        The <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KBRANCH" target="_top"><code class="filename">KBRANCH</code></a>
        variable must be set to indicate the branch.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            You can use the <code class="filename">KBRANCH</code> value to define an
            alternate branch typically with a machine override as shown here
            from the <code class="filename">meta-emenlow</code> layer:
            <pre class="literallayout">
     KBRANCH_emenlow-noemgd = "standard/base"
            </pre></div><p>
    </p><p>
        The linux-yocto style recipes can optionally define the following
        variables:
        </p><pre class="literallayout">
     KERNEL_FEATURES
     LINUX_KERNEL_TYPE
        </pre><p>
    </p><p>
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LINUX_KERNEL_TYPE" target="_top"><code class="filename">LINUX_KERNEL_TYPE</code></a>
        defines the kernel type to be
        used in assembling the configuration.
        If you do not specify a <code class="filename">LINUX_KERNEL_TYPE</code>,
        it defaults to "standard".
        Together with
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KMACHINE" target="_top"><code class="filename">KMACHINE</code></a>,
        <code class="filename">LINUX_KERNEL_TYPE</code> defines the search
        arguments used by the kernel tools to find the
        appropriate description within the kernel Metadata with which to
        build out the sources and configuration.
        The linux-yocto recipes define "standard", "tiny", and "preempt-rt"
        kernel types.
        See the "<a class="link" href="#kernel-types" title="3.3.4. Kernel Types">Kernel Types</a>" section
        for more information on kernel types.
    </p><p>
        During the build, the kern-tools search for the BSP description
        file that most closely matches the <code class="filename">KMACHINE</code>
        and <code class="filename">LINUX_KERNEL_TYPE</code> variables passed in from the
        recipe.
        The tools use the first BSP description it finds that match
        both variables.
        If the tools cannot find a match, they issue a warning such as
        the following:
        </p><pre class="literallayout">
     WARNING: Can't find any BSP hardware or required configuration fragments.
     WARNING: Looked at meta/cfg/broken/emenlow-broken/hdw_frags.txt and
              meta/cfg/broken/emenlow-broken/required_frags.txt in directory:
              meta/cfg/broken/emenlow-broken
        </pre><p>
        In this example, <code class="filename">KMACHINE</code> was set to "emenlow-broken"
        and <code class="filename">LINUX_KERNEL_TYPE</code> was set to "broken".
    </p><p>
        The tools first search for the <code class="filename">KMACHINE</code> and
        then for the <code class="filename">LINUX_KERNEL_TYPE</code>.
        If the tools cannot find a partial match, they will use the
        sources from the <code class="filename">KBRANCH</code> and any configuration
        specified in the
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>.
    </p><p>
        You can use the
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KERNEL_FEATURES" target="_top"><code class="filename">KERNEL_FEATURES</code></a>
        variable
        to include features (configuration fragments, patches, or both) that
        are not already included by the <code class="filename">KMACHINE</code> and
        <code class="filename">LINUX_KERNEL_TYPE</code> variable combination.
        For example, to include a feature specified as
        "features/netfilter/netfilter.scc",
        specify:
        </p><pre class="literallayout">
     KERNEL_FEATURES += "features/netfilter/netfilter.scc"
        </pre><p>
        To include a feature called "cfg/sound.scc" just for the
        <code class="filename">qemux86</code> machine, specify:
        </p><pre class="literallayout">
     KERNEL_FEATURES_append_qemux86 = " cfg/sound.scc"
        </pre><p>
        The value of the entries in <code class="filename">KERNEL_FEATURES</code>
        are dependent on their location within the kernel Metadata itself.
        The examples here are taken from the <code class="filename">meta</code>
        branch of the <code class="filename">linux-yocto-3.19</code> repository.
        Within that branch, "features" and "cfg" are subdirectories of the
        <code class="filename">meta/cfg/kernel-cache</code> directory.
        For more information, see the
        "<a class="link" href="#kernel-metadata-syntax" title="3.3. Kernel Metadata Syntax">Kernel Metadata Syntax</a>" section.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            The processing of the these variables has evolved some between the
	        0.9 and 1.3 releases of the Yocto Project and associated
	        kern-tools sources.
            The descriptions in this section are accurate for 1.3 and later
	        releases of the Yocto Project.
        </div><p>
    </p></div><div class="section" title="3.3. Kernel Metadata Syntax"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-metadata-syntax"></a>3.3. Kernel Metadata Syntax<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-metadata-syntax">¶</a></span></h2></div></div></div><p>
        The kernel Metadata consists of three primary types of files:
        <code class="filename">scc</code>
        <sup>[<a id="idm46143249720608" href="#ftn.idm46143249720608" class="footnote">1</a>]</sup>
        description files, configuration fragments, and patches.
        The <code class="filename">scc</code> files define variables and include or
        otherwise reference any of the three file types.
        The description files are used to aggregate all types of kernel
        Metadata into
        what ultimately describes the sources and the configuration required
        to build a Linux kernel tailored to a specific machine.
    </p><p>
        The <code class="filename">scc</code> description files are used to define two
        fundamental types of kernel Metadata:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Features</p></li><li class="listitem"><p>Board Support Packages (BSPs)</p></li></ul></div><p>
    </p><p>
        Features aggregate sources in the form of patches and configuration
        fragments into a modular reusable unit.
        You can use features to implement conceptually separate kernel
        Metadata descriptions such as pure configuration fragments,
        simple patches, complex features, and kernel types.
        <a class="link" href="#kernel-types" title="3.3.4. Kernel Types">Kernel types</a> define general
        kernel features and policy to be reused in the BSPs.
    </p><p>
        BSPs define hardware-specific features and aggregate them with kernel
        types to form the final description of what will be assembled and built.
    </p><p>
        While the kernel Metadata syntax does not enforce any logical
        separation of configuration fragments, patches, features or kernel
        types, best practices dictate a logical separation of these types
        of Metadata.
        The following Metadata file hierarchy is recommended:
        </p><pre class="literallayout">
     <em class="replaceable"><code>base</code></em>/
        bsp/
        cfg/
        features/
        ktypes/
        patches/
        </pre><p>
    </p><p>
        The <code class="filename">bsp</code> directory contains the
        <a class="link" href="#bsp-descriptions" title="3.3.5. BSP Descriptions">BSP descriptions</a>.
        The remaining directories all contain "features".
        Separating <code class="filename">bsp</code> from the rest of the structure
        aids conceptualizing intended usage.
    </p><p>
        Use these guidelines to help place your <code class="filename">scc</code>
        description files within the structure:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If your file contains
                only configuration fragments, place the file in the
                <code class="filename">cfg</code> directory.</p></li><li class="listitem"><p>If your file contains
                only source-code fixes, place the file in the
                <code class="filename">patches</code> directory.</p></li><li class="listitem"><p>If your file encapsulates
                a major feature, often combining sources and configurations,
                place the file in <code class="filename">features</code> directory.
                </p></li><li class="listitem"><p>If your file aggregates
                non-hardware configuration and patches in order to define a
                base kernel policy or major kernel type to be reused across
                multiple BSPs, place the file in <code class="filename">ktypes</code>
                directory.
                </p></li></ul></div><p>
    </p><p>
        These distinctions can easily become blurred - especially as
        out-of-tree features slowly merge upstream over time.
        Also, remember that how the description files are placed is
        a purely logical organization and has no impact on the functionality
        of the kernel Metadata.
        There is no impact because all of <code class="filename">cfg</code>,
        <code class="filename">features</code>, <code class="filename">patches</code>, and
        <code class="filename">ktypes</code>, contain "features" as far as the kernel
        tools are concerned.
    </p><p>
        Paths used in kernel Metadata files are relative to
        <code class="filename">&lt;base&gt;</code>, which is either
        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESEXTRAPATHS" target="_top"><code class="filename">FILESEXTRAPATHS</code></a>
        if you are creating Metadata in
        <a class="link" href="#recipe-space-metadata" title="3.4.1. Recipe-Space Metadata">recipe-space</a>,
        or <code class="filename">meta/cfg/kernel-cache/</code> if you are creating
        <a class="link" href="#metadata-outside-the-recipe-space" title="3.4.2. Metadata Outside the Recipe-Space">Metadata outside of the recipe-space</a>.
    </p><div class="section" title="3.3.1. Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="configuration"></a>3.3.1. Configuration<span class="permalink"><a alt="Permalink" title="Permalink" href="#configuration">¶</a></span></h3></div></div></div><p>
            The simplest unit of kernel Metadata is the configuration-only
            feature.
            This feature consists of one or more Linux kernel configuration
            parameters in a configuration fragment file
            (<code class="filename">.cfg</code>) and a <code class="filename">.scc</code> file
            that describes the fragment.
        </p><p>
            The Symmetric Multi-Processing (SMP) fragment included in the
            <code class="filename">linux-yocto-3.19</code> Git repository
            consists of the following two files:
            </p><pre class="literallayout">
     cfg/smp.scc:
        define KFEATURE_DESCRIPTION "Enable SMP"
        define KFEATURE_COMPATIBILITY all

        kconf hardware smp.cfg

     cfg/smp.cfg:
        CONFIG_SMP=y
        CONFIG_SCHED_SMT=y
        # Increase default NR_CPUS from 8 to 64 so that platform with
        # more than 8 processors can be all activated at boot time
        CONFIG_NR_CPUS=64
            </pre><p>
            You can find information on configuration fragment files in the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#creating-config-fragments" target="_top">Creating Configuration Fragments</a>"
            section of the Yocto Project Development Manual and in
            the "<a class="link" href="#generating-configuration-files" title="2.3.2. Generating Configuration Files">Generating Configuration Files</a>"
            section earlier in this manual.
        </p><p>
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KFEATURE_DESCRIPTION" target="_top"><code class="filename">KFEATURE_DESCRIPTION</code></a>
            provides a short description of the fragment.
            Higher level kernel tools use this description.
        </p><p>
            The <code class="filename">kconf</code> command is used to include the
            actual configuration fragment in an <code class="filename">.scc</code>
            file, and the "hardware" keyword identifies the fragment as
            being hardware enabling, as opposed to general policy,
            which would use the "non-hardware" keyword.
            The distinction is made for the benefit of the configuration
            validation tools, which warn you if a hardware fragment
            overrides a policy set by a non-hardware fragment.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                The description file can include multiple
                <code class="filename">kconf</code> statements, one per fragment.
            </div><p>
        </p><p>
            As described in the
            "<a class="link" href="#generating-configuration-files" title="2.3.2. Generating Configuration Files">Generating Configuration Files</a>"
            section, you can use the following BitBake command to audit your
            configuration:
            </p><pre class="literallayout">
     $ bitbake linux-yocto -c kernel_configcheck -f
            </pre><p>
        </p></div><div class="section" title="3.3.2. Patches"><div class="titlepage"><div><div><h3 class="title"><a id="patches"></a>3.3.2. Patches<span class="permalink"><a alt="Permalink" title="Permalink" href="#patches">¶</a></span></h3></div></div></div><p>
            Patch descriptions are very similar to configuration fragment
            descriptions, which are described in the previous section.
            However, instead of a <code class="filename">.cfg</code> file, these
            descriptions work with source patches.
        </p><p>
            A typical patch includes a description file and the patch itself:
            </p><pre class="literallayout">
     patches/mypatch.scc:
        patch mypatch.patch

     patches/mypatch.patch:
        <em class="replaceable"><code>typical-patch</code></em>
            </pre><p>
            You can create the typical <code class="filename">.patch</code>
            file using <code class="filename">diff -Nurp</code> or
            <code class="filename">git format-patch</code>.
        </p><p>
            The description file can include multiple patch statements,
            one per patch.
        </p></div><div class="section" title="3.3.3. Features"><div class="titlepage"><div><div><h3 class="title"><a id="features"></a>3.3.3. Features<span class="permalink"><a alt="Permalink" title="Permalink" href="#features">¶</a></span></h3></div></div></div><p>
            Features are complex kernel Metadata types that consist
            of configuration fragments (<code class="filename">kconf</code>), patches
            (<code class="filename">patch</code>), and possibly other feature
            description files (<code class="filename">include</code>).
        </p><p>
            Here is an example that shows a feature description file:
            </p><pre class="literallayout">
     features/myfeature.scc
        define KFEATURE_DESCRIPTION "Enable myfeature"

        patch 0001-myfeature-core.patch
        patch 0002-myfeature-interface.patch

        include cfg/myfeature_dependency.scc
        kconf non-hardware myfeature.cfg
            </pre><p>
            This example shows how the <code class="filename">patch</code> and
            <code class="filename">kconf</code> commands are used as well as
            how an additional feature description file is included.
        </p><p>
            Typically, features are less granular than configuration
            fragments and are more likely than configuration fragments
            and patches to be the types of things you want to specify
            in the <code class="filename">KERNEL_FEATURES</code> variable of the
            Linux kernel recipe.
            See the "<a class="link" href="#using-kernel-metadata-in-a-recipe" title="3.2. Using Kernel Metadata in a Recipe">Using Kernel Metadata in a Recipe</a>"
            section earlier in the manual.
        </p></div><div class="section" title="3.3.4. Kernel Types"><div class="titlepage"><div><div><h3 class="title"><a id="kernel-types"></a>3.3.4. Kernel Types<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-types">¶</a></span></h3></div></div></div><p>
            A kernel type defines a high-level kernel policy by
            aggregating non-hardware configuration fragments with
            patches you want to use when building a Linux kernels of a
            specific type.
            Syntactically, kernel types are no different than features
            as described in the "<a class="link" href="#features" title="3.3.3. Features">Features</a>"
            section.
            The <code class="filename">LINUX_KERNEL_TYPE</code> variable in the kernel
            recipe selects the kernel type.
            See the "<a class="link" href="#using-kernel-metadata-in-a-recipe" title="3.2. Using Kernel Metadata in a Recipe">Using Kernel Metadata in a Recipe</a>"
            section for more information.
        </p><p>
            As an example, the <code class="filename">linux-yocto-3.19</code>
            tree defines three kernel types: "standard",
            "tiny", and "preempt-rt":
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>"standard":
                    Includes the generic Linux kernel policy of the Yocto
                    Project linux-yocto kernel recipes.
                    This policy includes, among other things, which file
                    systems, networking options, core kernel features, and
                    debugging and tracing options are supported.
                    </p></li><li class="listitem"><p>"preempt-rt":
                    Applies the <code class="filename">PREEMPT_RT</code>
                    patches and the configuration options required to
                    build a real-time Linux kernel.
                    This kernel type inherits from the "standard" kernel type.
                    </p></li><li class="listitem"><p>"tiny":
                    Defines a bare minimum configuration meant to serve as a
                    base for very small Linux kernels.
                    The "tiny" kernel type is independent from the "standard"
                    configuration.
                    Although the "tiny" kernel type does not currently include
                    any source changes, it might in the future.
                    </p></li></ul></div><p>
        </p><p>
            The "standard" kernel type is defined by
            <code class="filename">standard.scc</code>:
            </p><pre class="literallayout">
     # Include this kernel type fragment to get the standard features and
     # configuration values.

     # Include all standard features
     include standard-nocfg.scc

     kconf non-hardware standard.cfg

     # individual cfg block section
     include cfg/fs/devtmpfs.scc
     include cfg/fs/debugfs.scc
     include cfg/fs/btrfs.scc
     include cfg/fs/ext2.scc
     include cfg/fs/ext3.scc
     include cfg/fs/ext4.scc

     include cfg/net/ipv6.scc
     include cfg/net/ip_nf.scc
     include cfg/net/ip6_nf.scc
     include cfg/net/bridge.scc
            </pre><p>
        </p><p>
            As with any <code class="filename">.scc</code> file, a
            kernel type definition can aggregate other
            <code class="filename">.scc</code> files with
            <code class="filename">include</code> commands.
            These definitions can also directly pull in
            configuration fragments and patches with the
            <code class="filename">kconf</code> and <code class="filename">patch</code>
            commands, respectively.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
            It is not strictly necessary to create a kernel type
            <code class="filename">.scc</code> file.
            The Board Support Package (BSP) file can implicitly define
            the kernel type using a <code class="filename">define
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KTYPE" target="_top">KTYPE</a> myktype</code>
            line.
            See the "<a class="link" href="#bsp-descriptions" title="3.3.5. BSP Descriptions">BSP Descriptions</a>"
            section for more information.
        </div></div><div class="section" title="3.3.5. BSP Descriptions"><div class="titlepage"><div><div><h3 class="title"><a id="bsp-descriptions"></a>3.3.5. BSP Descriptions<span class="permalink"><a alt="Permalink" title="Permalink" href="#bsp-descriptions">¶</a></span></h3></div></div></div><p>
            BSP descriptions (i.e. <code class="filename">*.scc</code> files)
            combine kernel types with hardware-specific features.
            The hardware-specific Metadata is typically defined
            independently in the BSP layer, and then aggregated with each
            supported kernel type.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                For BSPs supported by the Yocto Project, the BSP description
                files are located in the <code class="filename">bsp</code> directory
                of the <code class="filename">yocto-kernel-cache</code> repository
                organized under the "Yocto Linux Kernel" heading in the
                <a class="ulink" href="http://git.yoctoproject.org/cgit/cgit.cgi" target="_top">Yocto Project Source Repositories</a>.
            </div><p>
        </p><p>
            This section provides a BSP description structural overview along
            with aggregation concepts as well as a detailed example using
            a BSP supported by the Yocto Project (i.e. Minnow Board).
        </p><div class="section" title="3.3.5.1. Overview"><div class="titlepage"><div><div><h4 class="title"><a id="bsp-description-file-overview"></a>3.3.5.1. Overview<span class="permalink"><a alt="Permalink" title="Permalink" href="#bsp-description-file-overview">¶</a></span></h4></div></div></div><p>
                For simplicity, consider the following top-level BSP
                description file.
                Top-level BSP descriptions files employ both a structure
                and naming convention for consistency.
                The naming convention for the file is as follows:
                </p><pre class="literallayout">
     <em class="replaceable"><code>bsp_name</code></em>-<em class="replaceable"><code>kernel_type</code></em>.scc
                </pre><p>
                Here are some example top-level BSP filenames for the
                Minnow Board BSP, which is supported by the Yocto Project:
                </p><pre class="literallayout">
     minnow-standard.scc
     minnow-preempt-rt.scc
     minnow-tiny.scc
                </pre><p>
                Each file uses the BSP name followed by the kernel type.
            </p><p>
                is simple BSP description file whose name has the
                form
                <em class="replaceable"><code>mybsp</code></em><code class="filename">-standard</code>
                and supports the <em class="replaceable"><code>mybsp</code></em> machine using
                a standard kernel:
                </p><pre class="literallayout">
     define KMACHINE <em class="replaceable"><code>mybsp</code></em>
     define KTYPE standard
     define KARCH i386

     include ktypes/standard

     include <em class="replaceable"><code>mybsp</code></em>.scc

     kconf hardware <em class="replaceable"><code>mybsp</code></em>-<em class="replaceable"><code>extra</code></em>.cfg
                </pre><p>
                Every top-level BSP description file should define the
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KMACHINE" target="_top"><code class="filename">KMACHINE</code></a>,
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KTYPE" target="_top"><code class="filename">KTYPE</code></a>,
                and <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KARCH" target="_top"><code class="filename">KARCH</code></a>
                variables.
                These variables allow the OpenEmbedded build system to identify
                the description as meeting the criteria set by the recipe being
                built.
                This simple example supports the "mybsp" machine for the "standard"
                kernel and the "i386" architecture.
            </p><p>
                Be aware that a hard link between the
                <code class="filename">KTYPE</code> variable and a kernel type description
                file does not exist.
                Thus, if you do not have kernel types defined in your kernel
                Metadata, you only need to ensure that the kernel recipe's
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-LINUX_KERNEL_TYPE" target="_top"><code class="filename">LINUX_KERNEL_TYPE</code></a>
                variable and the <code class="filename">KTYPE</code> variable in the
                BSP description file match.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    Future versions of the tooling make the specification of
                    <code class="filename">KTYPE</code> in the BSP optional.
                </div><p>
            </p><p>
                To separate your kernel policy from your hardware configuration,
                you include a kernel type (<code class="filename">ktype</code>), such as
                "standard".
                In the previous example, this is done using the following:
                </p><pre class="literallayout">
     include ktypes/standard
                </pre><p>
                In the previous example, <code class="filename">ktypes/standard.scc</code>
                aggregates all the configuration fragments, patches, and
                features that make up your standard kernel policy.
                See the "<a class="link" href="#kernel-types" title="3.3.4. Kernel Types">Kernel Types</a>" section
                for more information.
            </p><p>
                To aggregate common configurations and features specific to the
                kernel for <em class="replaceable"><code>mybsp</code></em>, use the following:
                </p><pre class="literallayout">
     include <em class="replaceable"><code>mybsp</code></em>.scc
                </pre><p>
                For information on how to break a complete
                <code class="filename">.config</code> file into the various
                configuration fragments, see the
                "<a class="link" href="#generating-configuration-files" title="2.3.2. Generating Configuration Files">Generating Configuration Files</a>"
                section.
            </p><p>
                Finally, if you have any configurations specific to the
                hardware that are not in a <code class="filename">*.scc</code> file,
                you can include them as follows:
                </p><pre class="literallayout">
     kconf hardware <em class="replaceable"><code>mybsp</code></em>-<em class="replaceable"><code>extra</code></em>.cfg
                </pre><p>
            </p></div><div class="section" title="3.3.5.2. Example"><div class="titlepage"><div><div><h4 class="title"><a id="bsp-description-file-example-minnow"></a>3.3.5.2. Example<span class="permalink"><a alt="Permalink" title="Permalink" href="#bsp-description-file-example-minnow">¶</a></span></h4></div></div></div><p>
                Many real-world examples are more complex.
                Like any other <code class="filename">.scc</code> file, BSP
                descriptions can aggregate features.
                Consider the Minnow BSP definition from the
                <code class="filename">linux-yocto-4.4</code> in the
                Yocto Project
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#source-repositories" target="_top">Source Repositories</a>
                (i.e.
                <code class="filename">yocto-kernel-cache/bsp/minnow</code>):
                </p><pre class="literallayout">
     minnow.scc:
         include cfg/x86.scc
         include features/eg20t/eg20t.scc
         include cfg/dmaengine.scc
         include features/power/intel.scc
         include cfg/efi.scc
         include features/usb/ehci-hcd.scc
         include features/usb/ohci-hcd.scc
         include features/usb/usb-gadgets.scc
         include features/usb/touchscreen-composite.scc
         include cfg/timer/hpet.scc
         include features/leds/leds.scc
         include features/spi/spidev.scc
         include features/i2c/i2cdev.scc
         include features/mei/mei-txe.scc

         # Earlyprintk and port debug requires 8250
         kconf hardware cfg/8250.cfg

         kconf hardware minnow.cfg
         kconf hardware minnow-dev.cfg
                </pre><p>
            </p><p>
                The <code class="filename">minnow.scc</code> description file includes
                a hardware configuration fragment
                (<code class="filename">minnow.cfg</code>) specific to the Minnow
                BSP as well as several more general configuration
                fragments and features enabling hardware found on the
                machine.
                This <code class="filename">minnow.scc</code> description file is then
                included in each of the three
                "minnow" description files for the supported kernel types
                (i.e. "standard", "preempt-rt", and "tiny").
                Consider the "minnow" description for the "standard" kernel
                type:
                </p><pre class="literallayout">
     minnow-standard.scc:
         define KMACHINE minnow
         define KTYPE standard
         define KARCH i386

         include ktypes/standard

         include minnow.scc

         # Extra minnow configs above the minimal defined in minnow.scc
         include cfg/efi-ext.scc
         include features/media/media-all.scc
         include features/sound/snd_hda_intel.scc

         # The following should really be in standard.scc
         # USB live-image support
         include cfg/usb-mass-storage.scc
         include cfg/boot-live.scc

         # Basic profiling
         include features/latencytop/latencytop.scc
         include features/profiling/profiling.scc

         # Requested drivers that don't have an existing scc
         kconf hardware minnow-drivers-extra.cfg
                </pre><p>
                The <code class="filename">include</code> command midway through the file
                includes the <code class="filename">minnow.scc</code> description that
                defines all enabled hardware for the BSP that is common to
                all kernel types.
                Using this command significantly reduces duplication.
            </p><p>
                Now consider the "minnow" description for the "tiny" kernel
                type:
                </p><pre class="literallayout">
     minnow-tiny.scc:
        define KMACHINE minnow
        define KTYPE tiny
        define KARCH i386

        include ktypes/tiny

        include minnow.scc
                </pre><p>
                As you might expect, the "tiny" description includes quite a
                bit less.
                In fact, it includes only the minimal policy defined by the
                "tiny" kernel type and the hardware-specific configuration
                required for booting the machine along with the most basic
                functionality of the system as defined in the base "minnow"
                description file.
            </p><p>
                Notice again the three critical variables:
                <code class="filename">KMACHINE</code>, <code class="filename">KTYPE</code>,
                and <code class="filename">KARCH</code>.
                Of these variables, only the <code class="filename">KTYPE</code> has changed.
                It is now set to "tiny".
            </p></div></div></div><div class="section" title="3.4. Kernel Metadata Location"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-metadata-location"></a>3.4. Kernel Metadata Location<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-metadata-location">¶</a></span></h2></div></div></div><p>
        Kernel Metadata always exists outside of the kernel tree either
        defined in a kernel recipe (recipe-space) or outside of the recipe.
        Where you choose to define the Metadata depends on what you want
        to do and how you intend to work.
        Regardless of where you define the kernel Metadata, the syntax used
        applies equally.
    </p><p>
        If you are unfamiliar with the Linux kernel and only wish
        to apply a configuration and possibly a couple of patches provided to
        you by others, the recipe-space method is recommended.
        This method is also a good approach if you are working with Linux kernel
        sources you do not control or if you just do not want to maintain a
        Linux kernel Git repository on your own.
        For partial information on how you can define kernel Metadata in
        the recipe-space, see the
        "<a class="link" href="#modifying-an-existing-recipe" title="2.2. Modifying an Existing Recipe">Modifying an Existing Recipe</a>"
        section.
    </p><p>
        Conversely, if you are actively developing a kernel and are already
        maintaining a Linux kernel Git repository of your own, you might find
        it more convenient to work with kernel Metadata kept outside the
        recipe-space.
        Working with Metadata in this area can make iterative development of
        the Linux kernel more efficient outside of the BitBake environment.
    </p><div class="section" title="3.4.1. Recipe-Space Metadata"><div class="titlepage"><div><div><h3 class="title"><a id="recipe-space-metadata"></a>3.4.1. Recipe-Space Metadata<span class="permalink"><a alt="Permalink" title="Permalink" href="#recipe-space-metadata">¶</a></span></h3></div></div></div><p>
            When stored in recipe-space, the kernel Metadata files reside in a
            directory hierarchy below
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-FILESEXTRAPATHS" target="_top"><code class="filename">FILESEXTRAPATHS</code></a>.
            For a linux-yocto recipe or for a Linux kernel recipe derived
            by copying and modifying
            <code class="filename">oe-core/meta-skeleton/recipes-kernel/linux/linux-yocto-custom.bb</code>
            to a recipe in your layer, <code class="filename">FILESEXTRAPATHS</code>
            is typically set to
            <code class="filename">${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-THISDIR" target="_top"><code class="filename">THISDIR</code></a><code class="filename">}/${</code><a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PN" target="_top"><code class="filename">PN</code></a><code class="filename">}</code>.
            See the "<a class="link" href="#modifying-an-existing-recipe" title="2.2. Modifying an Existing Recipe">Modifying an Existing Recipe</a>"
            section for more information.
        </p><p>
            Here is an example that shows a trivial tree of kernel Metadata
            stored in recipe-space within a BSP layer:
            </p><pre class="literallayout">
     meta-<em class="replaceable"><code>my_bsp_layer</code></em>/
     `-- recipes-kernel
         `-- linux
             `-- linux-yocto
                 |-- bsp-standard.scc
                 |-- bsp.cfg
                 `-- standard.cfg
            </pre><p>
        </p><p>
            When the Metadata is stored in recipe-space, you must take
            steps to ensure BitBake has the necessary information to decide
            what files to fetch and when they need to be fetched again.
            It is only necessary to specify the <code class="filename">.scc</code>
            files on the
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>.
            BitBake parses them and fetches any files referenced in the
            <code class="filename">.scc</code> files by the <code class="filename">include</code>,
            <code class="filename">patch</code>, or <code class="filename">kconf</code> commands.
            Because of this, it is necessary to bump the recipe
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-PR" target="_top"><code class="filename">PR</code></a>
            value when changing the content of files not explicitly listed
            in the <code class="filename">SRC_URI</code>.
        </p><p>
            If the BSP description is in recipe space, you cannot simply list
            the <code class="filename">*.scc</code> in the <code class="filename">SRC_URI</code>
            statement.
            You need to use the following form from your kernel append file:
            </p><pre class="literallayout">
     SRC_URI_append_<em class="replaceable"><code>myplatform</code></em> = " \
        file://<em class="replaceable"><code>myplatform</code></em>;type=kmeta;destsuffix=<em class="replaceable"><code>myplatform</code></em> \
        "
            </pre><p>
        </p></div><div class="section" title="3.4.2. Metadata Outside the Recipe-Space"><div class="titlepage"><div><div><h3 class="title"><a id="metadata-outside-the-recipe-space"></a>3.4.2. Metadata Outside the Recipe-Space<span class="permalink"><a alt="Permalink" title="Permalink" href="#metadata-outside-the-recipe-space">¶</a></span></h3></div></div></div><p>
            When stored outside of the recipe-space, the kernel Metadata
            files reside in a separate repository.
            The OpenEmbedded build system adds the Metadata to the build as
            a "ktype=meta" repository through the
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a>
            variable.
            As an example, consider the following <code class="filename">SRC_URI</code>
            statement from the <code class="filename">linux-yocto_4.4.bb</code>
            kernel recipe:
            </p><pre class="literallayout">
     SRC_URI = "git://git.yoctoproject.org/linux-yocto-4.4.git;name=machine;branch=${KBRANCH}; \
                git://git.yoctoproject.org/yocto-kernel-cache;type=kmeta;name=meta;branch=yocto-4.4;destsuffix=${KMETA}"
            </pre><p>
            <code class="filename">${KMETA}</code>, in this context, is simply used to
            name the directory into which the Git fetcher places the Metadata.
            This behavior is no different than any multi-repository
            <code class="filename">SRC_URI</code> statement used in a recipe (e.g.
            see the previous section).
        </p><p>
            You can keep kernel Metadata in a "kernel-cache", which is a
            directory containing configuration fragments.
            As with any Metadata kept outside the recipe-space, you simply
            need to use the <code class="filename">SRC_URI</code> statement with the
            "type=kmeta" attribute.
            Doing so makes the kernel Metadata available during the
            configuration phase.
        </p><p>
            If you modify the Metadata, you must not forget to update the
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRCREV" target="_top"><code class="filename">SRCREV</code></a>
            statements in the kernel's recipe.
            In particular, you need to update the
            <code class="filename">SRCREV_meta</code> variable to match the commit in
            the <code class="filename">KMETA</code> branch you wish to use.
            Changing the data in these branches and not updating the
            <code class="filename">SRCREV</code> statements to match will cause the
            build to fetch an older commit.
        </p></div></div><div class="section" title="3.5. Organizing Your Source"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="organizing-your-source"></a>3.5. Organizing Your Source<span class="permalink"><a alt="Permalink" title="Permalink" href="#organizing-your-source">¶</a></span></h2></div></div></div><p>
        Many recipes based on the <code class="filename">linux-yocto-custom.bb</code>
        recipe use Linux kernel sources that have only a single
        branch - "master".
        This type of repository structure is fine for linear development
        supporting a single machine and architecture.
        However, if you work with multiple boards and architectures,
        a kernel source repository with multiple branches is more
        efficient.
        For example, suppose you need a series of patches for one board to boot.
        Sometimes, these patches are works-in-progress or fundamentally wrong,
        yet they are still necessary for specific boards.
        In these situations, you most likely do not want to include these
        patches in every kernel you build (i.e. have the patches as part of
        the lone "master" branch).
        It is situations like these that give rise to multiple branches used
        within a Linux kernel sources Git repository.
    </p><p>
        Repository organization strategies exist that maximize source reuse,
        remove redundancy, and logically order your changes.
        This section presents strategies for the following cases:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Encapsulating patches in a feature description
                and only including the patches in the BSP descriptions of
                the applicable boards.</p></li><li class="listitem"><p>Creating a machine branch in your
                kernel source repository and applying the patches on that
                branch only.</p></li><li class="listitem"><p>Creating a feature branch in your
                kernel source repository and merging that branch into your
                BSP when needed.</p></li></ul></div><p>
    </p><p>
        The approach you take is entirely up to you
        and depends on what works best for your development model.
    </p><div class="section" title="3.5.1. Encapsulating Patches"><div class="titlepage"><div><div><h3 class="title"><a id="encapsulating-patches"></a>3.5.1. Encapsulating Patches<span class="permalink"><a alt="Permalink" title="Permalink" href="#encapsulating-patches">¶</a></span></h3></div></div></div><p>
            if you are reusing patches from an external tree and are not
            working on the patches, you might find the encapsulated feature
            to be appropriate.
            Given this scenario, you do not need to create any branches in the
            source repository.
            Rather, you just take the static patches you need and encapsulate
            them within a feature description.
            Once you have the feature description, you simply include that into
            the BSP description as described in the
            "<a class="link" href="#bsp-descriptions" title="3.3.5. BSP Descriptions">BSP Descriptions</a>"
            section.
        </p><p>
            You can find information on how to create patches and BSP
            descriptions in the "<a class="link" href="#patches" title="3.3.2. Patches">Patches</a>" and
            "<a class="link" href="#bsp-descriptions" title="3.3.5. BSP Descriptions">BSP Descriptions</a>"
            sections.
        </p></div><div class="section" title="3.5.2. Machine Branches"><div class="titlepage"><div><div><h3 class="title"><a id="machine-branches"></a>3.5.2. Machine Branches<span class="permalink"><a alt="Permalink" title="Permalink" href="#machine-branches">¶</a></span></h3></div></div></div><p>
            When you have multiple machines and architectures to support,
            or you are actively working on board support, it is more
            efficient to create branches in the repository based on
            individual machines.
            Having machine branches allows common source to remain in the
            "master" branch with any features specific to a machine stored
            in the appropriate machine branch.
            This organization method frees you from continually reintegrating
            your patches into a feature.
        </p><p>
            Once you have a new branch, you can set up your kernel Metadata
            to use the branch a couple different ways.
            In the recipe, you can specify the new branch as the
            <code class="filename">KBRANCH</code> to use for the board as
            follows:
            </p><pre class="literallayout">
     KBRANCH = "mynewbranch"
            </pre><p>
            Another method is to use the <code class="filename">branch</code> command
            in the BSP description:
            </p><pre class="literallayout">
     mybsp.scc:
        define KMACHINE mybsp
        define KTYPE standard
        define KARCH i386
        include standard.scc

        branch mynewbranch

        include mybsp-hw.scc
            </pre><p>
        </p><p>
            If you find
            yourself with numerous branches, you might consider using a
            hierarchical branching system similar to what the linux-yocto Linux
            kernel repositories use:
            </p><pre class="literallayout">
     <em class="replaceable"><code>common</code></em>/<em class="replaceable"><code>kernel_type</code></em>/<em class="replaceable"><code>machine</code></em>
            </pre><p>
        </p><p>
            If you had two kernel types, "standard" and "small" for
            instance, three machines, and <em class="replaceable"><code>common</code></em>
            as <code class="filename">mydir</code>, the branches in your
            Git repository might look like this:
            </p><pre class="literallayout">
     mydir/base
     mydir/standard/base
     mydir/standard/machine_a
     mydir/standard/machine_b
     mydir/standard/machine_c
     mydir/small/base
     mydir/small/machine_a
            </pre><p>
        </p><p>
            This organization can help clarify the branch relationships.
            In this case, <code class="filename">mydir/standard/machine_a</code>
            includes everything in <code class="filename">mydir/base</code> and
            <code class="filename">mydir/standard/base</code>.
            The "standard" and "small" branches add sources specific to those
            kernel types that for whatever reason are not appropriate for the
            other branches.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>The "base" branches are an artifact of the way Git manages
                its data internally on the filesystem: Git will not allow you
                to use <code class="filename">mydir/standard</code> and
                <code class="filename">mydir/standard/machine_a</code> because it
                would have to create a file and a directory named "standard".
            </div><p>
        </p></div><div class="section" title="3.5.3. Feature Branches"><div class="titlepage"><div><div><h3 class="title"><a id="feature-branches"></a>3.5.3. Feature Branches<span class="permalink"><a alt="Permalink" title="Permalink" href="#feature-branches">¶</a></span></h3></div></div></div><p>
            When you are actively developing new features, it can be more
            efficient to work with that feature as a branch, rather than
            as a set of patches that have to be regularly updated.
            The Yocto Project Linux kernel tools provide for this with
            the <code class="filename">git merge</code> command.
        </p><p>
            To merge a feature branch into a BSP, insert the
            <code class="filename">git merge</code> command after any
            <code class="filename">branch</code> commands:
            </p><pre class="literallayout">
     mybsp.scc:
        define KMACHINE mybsp
        define KTYPE standard
        define KARCH i386
        include standard.scc

        branch mynewbranch
        git merge myfeature

        include mybsp-hw.scc
            </pre><p>
        </p></div></div><div class="section" title="3.6. SCC Description File Reference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="scc-reference"></a>3.6. SCC Description File Reference<span class="permalink"><a alt="Permalink" title="Permalink" href="#scc-reference">¶</a></span></h2></div></div></div><p>
        This section provides a brief reference for the commands you can use
        within an SCC description file (<code class="filename">.scc</code>):
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="filename">branch [ref]</code>:
                Creates a new branch relative to the current branch
                (typically <code class="filename">${KTYPE}</code>) using
                the currently checked-out branch, or "ref" if specified.
                </p></li><li class="listitem"><p><code class="filename">define</code>:
                Defines variables, such as <code class="filename">KMACHINE</code>,
                <code class="filename">KTYPE</code>, <code class="filename">KARCH</code>,
                and <code class="filename">KFEATURE_DESCRIPTION</code>.</p></li><li class="listitem"><p><code class="filename">include SCC_FILE</code>:
                Includes an SCC file in the current file.
                The file is parsed as if you had inserted it inline.
                </p></li><li class="listitem"><p><code class="filename">kconf [hardware|non-hardware] CFG_FILE</code>:
                Queues a configuration fragment for merging into the final
                Linux <code class="filename">.config</code> file.</p></li><li class="listitem"><p><code class="filename">git merge GIT_BRANCH</code>:
                Merges the feature branch into the current branch.
                </p></li><li class="listitem"><p><code class="filename">patch PATCH_FILE</code>:
                Applies the patch to the current Git branch.</p></li></ul></div><p>
    </p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.idm46143249720608" href="#idm46143249720608" class="para">1</a>] </sup>
                <code class="filename">scc</code> stands for Series Configuration
                Control, but the naming has less significance in the
                current implementation of the tooling than it had in the
                past.
                Consider <code class="filename">scc</code> files to be description files.
            </p></div></div></div>

    <div class="appendix" title="Appendix A. Advanced Kernel Concepts"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-dev-concepts-appx"></a>Appendix A. Advanced Kernel Concepts<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-concepts-appx">¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#kernel-big-picture">A.1. Yocto Project Kernel Development and Maintenance</a></span></dt><dt><span class="section"><a href="#kernel-architecture">A.2. Kernel Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#architecture-overview">A.2.1. Overview</a></span></dt><dt><span class="section"><a href="#branching-and-workflow">A.2.2. Branching Strategy and Workflow</a></span></dt><dt><span class="section"><a href="#source-code-manager-git">A.2.3. Source Code Manager - Git</a></span></dt></dl></dd></dl></div><div class="section" title="A.1. Yocto Project Kernel Development and Maintenance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-big-picture"></a>A.1. Yocto Project Kernel Development and Maintenance<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-big-picture">¶</a></span></h2></div></div></div><p>
            Kernels available through the Yocto Project, like other kernels, are based off the Linux
            kernel releases from <a class="ulink" href="http://www.kernel.org" target="_top">http://www.kernel.org</a>.
            At the beginning of a major development cycle, the Yocto Project team
            chooses its kernel based on factors such as release timing, the anticipated release
            timing of final upstream <code class="filename">kernel.org</code> versions, and Yocto Project
            feature requirements.
            Typically, the kernel chosen is in the
            final stages of development by the community.
            In other words, the kernel is in the release
            candidate or "rc" phase and not yet a final release.
            But, by being in the final stages of external development, the team knows that the
            <code class="filename">kernel.org</code> final release will clearly be within the early stages of
            the Yocto Project development window.
        </p><p>
            This balance allows the team to deliver the most up-to-date kernel
            possible, while still ensuring that the team has a stable official release for
            the baseline Linux kernel version.
        </p><p>
            The ultimate source for kernels available through the Yocto Project are released kernels
            from <code class="filename">kernel.org</code>.
            In addition to a foundational kernel from <code class="filename">kernel.org</code>, the
            kernels available contain a mix of important new mainline
            developments, non-mainline developments (when there is no alternative),
            Board Support Package (BSP) developments,
            and custom features.
            These additions result in a commercially released Yocto Project Linux kernel that caters
            to specific embedded designer needs for targeted hardware.
        </p><p>
            Once a kernel is officially released, the Yocto Project team goes into
            their next development cycle, or upward revision (uprev) cycle, while still
            continuing maintenance on the released kernel.
            It is important to note that the most sustainable and stable way
            to include feature development upstream is through a kernel uprev process.
            Back-porting hundreds of individual fixes and minor features from various
            kernel versions is not sustainable and can easily compromise quality.
        </p><p>
            During the uprev cycle, the Yocto Project team uses an ongoing analysis of
            kernel development, BSP support, and release timing to select the best
            possible <code class="filename">kernel.org</code> version.
            The team continually monitors community kernel
            development to look for significant features of interest.
            The team does consider back-porting large features if they have a significant advantage.
            User or community demand can also trigger a back-port or creation of new
            functionality in the Yocto Project baseline kernel during the uprev cycle.
        </p><p>
            Generally speaking, every new kernel both adds features and introduces new bugs.
            These consequences are the basic properties of upstream kernel development and are
            managed by the Yocto Project team's kernel strategy.
            It is the Yocto Project team's policy to not back-port minor features to the released kernel.
            They only consider back-porting significant technological jumps - and, that is done
            after a complete gap analysis.
            The reason for this policy is that back-porting any small to medium sized change
            from an evolving kernel can easily create mismatches, incompatibilities and very
            subtle errors.
        </p><p>
            These policies result in both a stable and a cutting
            edge kernel that mixes forward ports of existing features and significant and critical
            new functionality.
            Forward porting functionality in the kernels available through the Yocto Project kernel
            can be thought of as a "micro uprev."
            The many “micro uprevs” produce a kernel version with a mix of
            important new mainline, non-mainline, BSP developments and feature integrations.
            This kernel gives insight into new features and allows focused
            amounts of testing to be done on the kernel, which prevents
            surprises when selecting the next major uprev.
            The quality of these cutting edge kernels is evolving and the kernels are used in leading edge
            feature and BSP development.
        </p></div><div class="section" title="A.2. Kernel Architecture"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-architecture"></a>A.2. Kernel Architecture<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-architecture">¶</a></span></h2></div></div></div><p>
            This section describes the architecture of the kernels available through the
            Yocto Project and provides information
            on the mechanisms used to achieve that architecture.
        </p><div class="section" title="A.2.1. Overview"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-overview"></a>A.2.1. Overview<span class="permalink"><a alt="Permalink" title="Permalink" href="#architecture-overview">¶</a></span></h3></div></div></div><p>
                As mentioned earlier, a key goal of the Yocto Project is to present the
                developer with
                a kernel that has a clear and continuous history that is visible to the user.
                The architecture and mechanisms used achieve that goal in a manner similar to the
                upstream <code class="filename">kernel.org</code>.
            </p><p>
                You can think of a Yocto Project kernel as consisting of a baseline Linux kernel with
                added features logically structured on top of the baseline.
                The features are tagged and organized by way of a branching strategy implemented by the
                source code manager (SCM) Git.
                For information on Git as applied to the Yocto Project, see the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#git" target="_top">Git</a>" section in the
                Yocto Project Development Manual.
            </p><p>
                The result is that the user has the ability to see the added features and
                the commits that make up those features.
                In addition to being able to see added features, the user can also view the history of what
                made up the baseline kernel.
            </p><p>
                The following illustration shows the conceptual Yocto Project kernel.
            </p><p>
                </p><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr style="height: 630px"><td align="center"><img src="figures/kernel-architecture-overview.png" align="middle" /></td></tr></table><p>
            </p><p>
                In the illustration, the "Kernel.org Branch Point"
                marks the specific spot (or release) from
                which the Yocto Project kernel is created.
                From this point "up" in the tree, features and differences are organized and tagged.
            </p><p>
                The "Yocto Project Baseline Kernel" contains functionality that is common to every kernel
                type and BSP that is organized further up the tree.
                Placing these common features in the
                tree this way means features do not have to be duplicated along individual branches of the
                structure.
            </p><p>
                From the Yocto Project Baseline Kernel, branch points represent specific functionality
                for individual BSPs as well as real-time kernels.
                The illustration represents this through three BSP-specific branches and a real-time
                kernel branch.
                Each branch represents some unique functionality for the BSP or a real-time kernel.
            </p><p>
                In this example structure, the real-time kernel branch has common features for all
                real-time kernels and contains
                more branches for individual BSP-specific real-time kernels.
                The illustration shows three branches as an example.
                Each branch points the way to specific, unique features for a respective real-time
                kernel as they apply to a given BSP.
            </p><p>
                The resulting tree structure presents a clear path of markers (or branches) to the
                developer that, for all practical purposes, is the kernel needed for any given set
                of requirements.
            </p></div><div class="section" title="A.2.2. Branching Strategy and Workflow"><div class="titlepage"><div><div><h3 class="title"><a id="branching-and-workflow"></a>A.2.2. Branching Strategy and Workflow<span class="permalink"><a alt="Permalink" title="Permalink" href="#branching-and-workflow">¶</a></span></h3></div></div></div><p>
                The Yocto Project team creates kernel branches at points where functionality is
                no longer shared and thus, needs to be isolated.
                For example, board-specific incompatibilities would require different functionality
                and would require a branch to separate the features.
                Likewise, for specific kernel features, the same branching strategy is used.
            </p><p>
                This branching strategy results in a tree that has features organized to be specific
                for particular functionality, single kernel types, or a subset of kernel types.
                This strategy also results in not having to store the same feature twice
                internally in the tree.
                Rather, the kernel team stores the unique differences required to apply the
                feature onto the kernel type in question.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    The Yocto Project team strives to place features in the tree such that they can be
                    shared by all boards and kernel types where possible.
                    However, during development cycles or when large features are merged,
                    the team cannot always follow this practice.
                    In those cases, the team uses isolated branches to merge features.
                </div><p>
            </p><p>
                BSP-specific code additions are handled in a similar manner to kernel-specific additions.
                Some BSPs only make sense given certain kernel types.
                So, for these types, the team creates branches off the end of that kernel type for all
                of the BSPs that are supported on that kernel type.
                From the perspective of the tools that create the BSP branch, the BSP is really no
                different than a feature.
                Consequently, the same branching strategy applies to BSPs as it does to features.
                So again, rather than store the BSP twice, the team only stores the unique
                differences for the BSP across the supported multiple kernels.
            </p><p>
                While this strategy can result in a tree with a significant number of branches, it is
                important to realize that from the developer's point of view, there is a linear
                path that travels from the baseline <code class="filename">kernel.org</code>, through a select
                group of features and ends with their BSP-specific commits.
                In other words, the divisions of the kernel are transparent and are not relevant
                to the developer on a day-to-day basis.
                From the developer's perspective, this path is the "master" branch.
                The developer does not need to be aware of the existence of any other branches at all.
                Of course, there is value in the existence of these branches
                in the tree, should a person decide to explore them.
                For example, a comparison between two BSPs at either the commit level or at the line-by-line
                code <code class="filename">diff</code> level is now a trivial operation.
            </p><p>
                Working with the kernel as a structured tree follows recognized community best practices.
                In particular, the kernel as shipped with the product, should be
                considered an "upstream source" and viewed as a series of
                historical and documented modifications (commits).
                These modifications represent the development and stabilization done
                by the Yocto Project kernel development team.
            </p><p>
                Because commits only change at significant release points in the product life cycle,
                developers can work on a branch created
                from the last relevant commit in the shipped Yocto Project kernel.
                As mentioned previously, the structure is transparent to the developer
                because the kernel tree is left in this state after cloning and building the kernel.
            </p></div><div class="section" title="A.2.3. Source Code Manager - Git"><div class="titlepage"><div><div><h3 class="title"><a id="source-code-manager-git"></a>A.2.3. Source Code Manager - Git<span class="permalink"><a alt="Permalink" title="Permalink" href="#source-code-manager-git">¶</a></span></h3></div></div></div><p>
                The Source Code Manager (SCM) is Git.
                This SCM is the obvious mechanism for meeting the previously mentioned goals.
                Not only is it the SCM for <code class="filename">kernel.org</code> but,
                Git continues to grow in popularity and supports many different work flows,
                front-ends and management techniques.
            </p><p>
                You can find documentation on Git at <a class="ulink" href="http://git-scm.com/documentation" target="_top">http://git-scm.com/documentation</a>.
                You can also get an introduction to Git as it applies to the Yocto Project in the
                "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#git" target="_top">Git</a>"
                section in the Yocto Project Development Manual.
                These referenced sections overview Git and describe a minimal set of
                commands that allows you to be functional using Git.
                </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                    You can use as much, or as little, of what Git has to offer to accomplish what
                    you need for your project.
                    You do not have to be a "Git Master" in order to use it with the Yocto Project.
                </div><p>
            </p></div></div></div>

    <div class="appendix" title="Appendix B. Kernel Maintenance"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-dev-maint-appx"></a>Appendix B. Kernel Maintenance<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-maint-appx">¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#tree-construction">B.1. Tree Construction</a></span></dt><dt><span class="section"><a href="#build-strategy">B.2. Build Strategy</a></span></dt></dl></div><div class="section" title="B.1. Tree Construction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="tree-construction"></a>B.1. Tree Construction<span class="permalink"><a alt="Permalink" title="Permalink" href="#tree-construction">¶</a></span></h2></div></div></div><p>
            This section describes construction of the Yocto Project kernel source repositories
            as accomplished by the Yocto Project team to create kernel repositories.
            These kernel repositories are found under the heading "Yocto Linux Kernel" at
            <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>
            and can be shipped as part of a Yocto Project release.
            The team creates these repositories by
            compiling and executing the set of feature descriptions for every BSP
            and feature in the product.
            Those feature descriptions list all necessary patches,
            configuration, branching, tagging and feature divisions found in a kernel.
            Thus, the Yocto Project kernel repository (or tree) is built.
        </p><p>
            The existence of this tree allows you to access and clone a particular
            Yocto Project kernel repository and use it to build images based on their configurations
            and features.
        </p><p>
            You can find the files used to describe all the valid features and BSPs
            in the Yocto Project kernel in any clone of the Yocto Project kernel source repository
            Git tree.
            For example, the following command clones the Yocto Project baseline kernel that
            branched off of <code class="filename">linux.org</code> version 3.19:
            </p><pre class="literallayout">
     $ git clone git://git.yoctoproject.org/linux-yocto-3.19
            </pre><p>
            For another example of how to set up a local Git repository of the Yocto Project
            kernel files, see the
            "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#local-kernel-files" target="_top">Yocto Project Kernel</a>" bulleted
            item in the Yocto Project Development Manual.
        </p><p>
            Once you have cloned the kernel Git repository on your local machine, you can
            switch to the <code class="filename">meta</code> branch within the repository.
            Here is an example that assumes the local Git repository for the kernel is in
            a top-level directory named <code class="filename">linux-yocto-3.19</code>:
            </p><pre class="literallayout">
     $ cd linux-yocto-3.19
     $ git checkout -b meta origin/meta
            </pre><p>
            Once you have checked out and switched to the <code class="filename">meta</code> branch,
            you can see a snapshot of all the kernel configuration and feature descriptions that are
            used to build that particular kernel repository.
            These descriptions are in the form of <code class="filename">.scc</code> files.
        </p><p>
            You should realize, however, that browsing your local kernel repository
            for feature descriptions and patches is not an effective way to determine what is in a
            particular kernel branch.
            Instead, you should use Git directly to discover the changes in a branch.
            Using Git is an efficient and flexible way to inspect changes to the kernel.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
                Ground up reconstruction of the complete kernel tree is an action only taken by the
                Yocto Project team during an active development cycle.
                When you create a clone of the kernel Git repository, you are simply making it
                efficiently available for building and development.
            </div><p>
        </p><p>
            The following steps describe what happens when the Yocto Project Team constructs
            the Yocto Project kernel source Git repository (or tree) found at
            <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a> given the
            introduction of a new top-level kernel feature or BSP.
            These are the actions that effectively create the tree
            that includes the new feature, patch or BSP:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A top-level kernel feature is passed to the kernel build subsystem.
                    Normally, this feature is a BSP for a particular kernel type.</p></li><li class="listitem"><p>The file that describes the top-level feature is located by searching
                    these system directories:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The in-tree kernel-cache directories, which are located
                            in <code class="filename">meta/cfg/kernel-cache</code></p></li><li class="listitem"><p>Areas pointed to by <code class="filename">SRC_URI</code> statements
                            found in recipes</p></li></ul></div><p>
                    For a typical build, the target of the search is a
                    feature description in an <code class="filename">.scc</code> file
                    whose name follows this format:
                    </p><pre class="literallayout">
     <em class="replaceable"><code>bsp_name</code></em>-<em class="replaceable"><code>kernel_type</code></em>.scc
                    </pre><p>
                </p></li><li class="listitem"><p>Once located, the feature description is either compiled into a simple script
                    of actions, or into an existing equivalent script that is already part of the
                    shipped kernel.</p></li><li class="listitem"><p>Extra features are appended to the top-level feature description.
                    These features can come from the
                    <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-KERNEL_FEATURES" target="_top"><code class="filename">KERNEL_FEATURES</code></a>
                    variable in recipes.</p></li><li class="listitem"><p>Each extra feature is located, compiled and appended to the script
                    as described in step three.</p></li><li class="listitem"><p>The script is executed to produce a series of <code class="filename">meta-*</code>
                    directories.
                    These directories are descriptions of all the branches, tags, patches and configurations that
                    need to be applied to the base Git repository to completely create the
                    source (build) branch for the new BSP or feature.</p></li><li class="listitem"><p>The base repository is cloned, and the actions
                    listed in the <code class="filename">meta-*</code> directories are applied to the
                    tree.</p></li><li class="listitem"><p>The Git repository is left with the desired branch checked out and any
                    required branching, patching and tagging has been performed.</p></li></ol></div><p>
        </p><p>
            The kernel tree is now ready for developer consumption to be locally cloned,
            configured, and built into a Yocto Project kernel specific to some target hardware.
            </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The generated <code class="filename">meta-*</code> directories add to the kernel
                as shipped with the Yocto Project release.
                Any add-ons and configuration data are applied to the end of an existing branch.
                The full repository generation that is found in the
                official Yocto Project kernel repositories at
                <a class="ulink" href="http://git.yoctoproject.org/cgit.cgi" target="_top">http://git.yoctoproject.org/cgit.cgi</a>
                is the combination of all supported boards and configurations.</p><p>The technique the Yocto Project team uses is flexible and allows for seamless
                blending of an immutable history with additional patches specific to a
                deployment.
                Any additions to the kernel become an integrated part of the branches.</p></div><p>
        </p></div><div class="section" title="B.2. Build Strategy"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="build-strategy"></a>B.2. Build Strategy<span class="permalink"><a alt="Permalink" title="Permalink" href="#build-strategy">¶</a></span></h2></div></div></div><p>
            Once a local Git repository of the Yocto Project kernel exists on a development system,
            you can consider the compilation phase of kernel development - building a kernel image.
            Some prerequisites exist that are validated by the build process before compilation
            starts:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The
                <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-SRC_URI" target="_top"><code class="filename">SRC_URI</code></a> points
                to the kernel Git repository.</p></li><li class="listitem"><p>A BSP build branch exists.
                This branch has the following form:
                </p><pre class="literallayout">
     <em class="replaceable"><code>kernel_type</code></em>/<em class="replaceable"><code>bsp_name</code></em>
                </pre></li></ul></div><p>
            The OpenEmbedded build system makes sure these conditions exist before attempting compilation.
            Other means, however, do exist, such as as bootstrapping a BSP.
        </p><p>
            Before building a kernel, the build process verifies the tree
            and configures the kernel by processing all of the
            configuration "fragments" specified by feature descriptions in the <code class="filename">.scc</code>
            files.
            As the features are compiled, associated kernel configuration fragments are noted
            and recorded in the <code class="filename">meta-*</code> series of directories in their compilation order.
            The fragments are migrated, pre-processed and passed to the Linux Kernel
            Configuration subsystem (<code class="filename">lkc</code>) as raw input in the form
            of a <code class="filename">.config</code> file.
            The <code class="filename">lkc</code> uses its own internal dependency constraints to do the final
            processing of that information and generates the final <code class="filename">.config</code> file
            that is used during compilation.
        </p><p>
            Using the board's architecture and other relevant values from the board's template,
            kernel compilation is started and a kernel image is produced.
        </p><p>
            The other thing that you notice once you configure a kernel is that
            the build process generates a build tree that is separate from your kernel's local Git
            source repository tree.
            This build tree has a name that uses the following form, where
            <code class="filename">${MACHINE}</code> is the metadata name of the machine (BSP) and "kernel_type" is one
            of the Yocto Project supported kernel types (e.g. "standard"):
        </p><pre class="literallayout">
     linux-${MACHINE}-<em class="replaceable"><code>kernel_type</code></em>-build
        </pre><p>
        </p><p>
            The existing support in the <code class="filename">kernel.org</code> tree achieves this
            default functionality.
        </p><p>
            This behavior means that all the generated files for a particular machine or BSP are now in
            the build tree directory.
            The files include the final <code class="filename">.config</code> file, all the <code class="filename">.o</code>
            files, the <code class="filename">.a</code> files, and so forth.
            Since each machine or BSP has its own separate
            <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#build-directory" target="_top">Build Directory</a>
            in its own separate branch
            of the Git repository, you can easily switch between different builds.
        </p></div></div>



    <div class="appendix" title="Appendix C. Kernel Development FAQ"><div class="titlepage"><div><div><h2 class="title"><a id="kernel-dev-faq"></a>Appendix C. Kernel Development FAQ<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-faq">¶</a></span></h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl><dt><span class="section"><a href="#kernel-dev-faq-section">C.1. Common Questions and Solutions</a></span></dt></dl></div><div class="section" title="C.1. Common Questions and Solutions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="kernel-dev-faq-section"></a>C.1. Common Questions and Solutions<span class="permalink"><a alt="Permalink" title="Permalink" href="#kernel-dev-faq-section">¶</a></span></h2></div></div></div><p>
        The following lists some solutions for common questions.


        </p><div class="qandaset" title="Frequently Asked Questions"><a id="idm46143259393968"></a><dl><dt>C.1.1. <a href="#idm46143259393808">
                        How do I use my own Linux kernel .config
                        file?
                    </a></dt><dt>C.1.2. <a href="#idm46143251383952">
                        How do I create configuration fragments?
                    </a></dt><dt>C.1.3. <a href="#idm46143251382112">
                        How do I use my own Linux kernel sources?
                    </a></dt><dt>C.1.4. <a href="#idm46143251380272">
                        How do I install/not-install the kernel image on the rootfs?
                    </a></dt><dt>C.1.5. <a href="#idm46143249942384">
                        How do I install a specific kernel module?
                    </a></dt><dt>C.1.6. <a href="#idm46143249939600">
                        How do I change the Linux kernel command line?
                   </a></dt></dl><table border="0" width="100%" summary="Q and A Set"><col align="left" width="1%" /><col /><tbody><tr class="question" title="C.1.1."><td align="left" valign="top"><a id="idm46143259393808"></a><a id="idm46143259393648"></a><p><strong>C.1.1.</strong></p></td><td align="left" valign="top"><p>
                        How do I use my own Linux kernel <code class="filename">.config</code>
                        file?
                    </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                        Refer to the "<a class="link" href="#changing-the-configuration" title="2.2.3. Changing the Configuration">Changing the Configuration</a>"
                        section for information.
                    </p></td></tr><tr class="question" title="C.1.2."><td align="left" valign="top"><a id="idm46143251383952"></a><a id="idm46143251383824"></a><p><strong>C.1.2.</strong></p></td><td align="left" valign="top"><p>
                        How do I create configuration fragments?
                    </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                        Refer to the "<a class="link" href="#generating-configuration-files" title="2.3.2. Generating Configuration Files">Generating Configuration Files</a>"
                        section for information.
                    </p></td></tr><tr class="question" title="C.1.3."><td align="left" valign="top"><a id="idm46143251382112"></a><a id="idm46143251381984"></a><p><strong>C.1.3.</strong></p></td><td align="left" valign="top"><p>
                        How do I use my own Linux kernel sources?
                    </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                        Refer to the "<a class="link" href="#working-with-your-own-sources" title="2.4. Working With Your Own Sources">Working With Your Own Sources</a>"
                        section for information.
                    </p></td></tr><tr class="question" title="C.1.4."><td align="left" valign="top"><a id="idm46143251380272"></a><a id="idm46143251380144"></a><p><strong>C.1.4.</strong></p></td><td align="left" valign="top"><p>
                        How do I install/not-install the kernel image on the rootfs?
                    </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                        The kernel image (e.g. <code class="filename">vmlinuz</code>) is provided
                        by the <code class="filename">kernel-image</code> package.
                        Image recipes depend on <code class="filename">kernel-base</code>.
                        To specify whether or not the kernel
                        image is installed in the generated root filesystem, override
                        <code class="filename">RDEPENDS_kernel-base</code> to include or not
                        include "kernel-image".</p><p>See the
                        "<a class="ulink" href="http://www.yoctoproject.org/docs/2.3/dev-manual/dev-manual.html#using-bbappend-files" target="_top">Using .bbappend Files</a>"
                        section in the Yocto Project Development Manual for information on
                        how to use an append file to override metadata.
                    </p></td></tr><tr class="question" title="C.1.5."><td align="left" valign="top"><a id="idm46143249942384"></a><a id="idm46143249942256"></a><p><strong>C.1.5.</strong></p></td><td align="left" valign="top"><p>
                        How do I install a specific kernel module?
                    </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                        Linux kernel modules are packaged individually.
                        To ensure a specific kernel module is included in an image,
                        include it in the appropriate machine
                        <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-RRECOMMENDS" target="_top"><code class="filename">RRECOMMENDS</code></a>
                        variable.</p><p>These other variables are useful for installing specific
                        modules:
                        </p><pre class="literallayout">
     <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_ESSENTIAL_EXTRA_RDEPENDS" target="_top"><code class="filename">MACHINE_ESSENTIAL_EXTRA_RDEPENDS</code></a>
     <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS" target="_top"><code class="filename">MACHINE_ESSENTIAL_EXTRA_RRECOMMENDS</code></a>
     <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_EXTRA_RDEPENDS" target="_top"><code class="filename">MACHINE_EXTRA_RDEPENDS</code></a>
     <a class="ulink" href="http://www.yoctoproject.org/docs/2.3/ref-manual/ref-manual.html#var-MACHINE_EXTRA_RRECOMMENDS" target="_top"><code class="filename">MACHINE_EXTRA_RRECOMMENDS</code></a>
                        </pre><p>
                        For example, set the following in the <code class="filename">qemux86.conf</code>
                        file to include the <code class="filename">ab123</code> kernel modules
                        with images built for the <code class="filename">qemux86</code> machine:
                        </p><pre class="literallayout">
     MACHINE_EXTRA_RRECOMMENDS += "kernel-module-ab123"
                        </pre><p>
                        For more information, see the
                        "<a class="link" href="#incorporating-out-of-tree-modules" title="2.5.2. Incorporating Out-of-Tree Modules">Incorporating Out-of-Tree Modules</a>"
                        section.
                    </p></td></tr><tr class="question" title="C.1.6."><td align="left" valign="top"><a id="idm46143249939600"></a><a id="idm46143253133728"></a><p><strong>C.1.6.</strong></p></td><td align="left" valign="top"><p>
                        How do I change the Linux kernel command line?
                   </p></td></tr><tr class="answer"><td align="left" valign="top"></td><td align="left" valign="top"><p>
                        The Linux kernel command line is typically specified in
                        the machine config using the <code class="filename">APPEND</code> variable.
                For example, you can add some helpful debug information doing
                        the following:
                        </p><pre class="literallayout">
     APPEND += "printk.time=y initcall_debug debug"
                        </pre><p>
                    </p></td></tr></tbody></table></div><p>
    </p></div></div>



</div></body></html>